[
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is metadata about Dandiset 001354 version 0.250312.0036."
      },
      {
        "type": "text",
        "text": "{\n  \"id\": \"DANDI:001354/0.250312.0036\",\n  \"doi\": \"10.48324/dandi.001354/0.250312.0036\",\n  \"url\": \"https://dandiarchive.org/dandiset/001354/0.250312.0036\",\n  \"name\": \"Hippocampal neuronal responses to programmable antigen-gated G-protein-coupled engineered receptor activation\",\n  \"about\": [],\n  \"access\": [\n    {\n      \"status\": \"dandi:OpenAccess\",\n      \"schemaKey\": \"AccessRequirements\"\n    }\n  ],\n  \"license\": [\n    \"spdx:CC-BY-4.0\"\n  ],\n  \"version\": \"0.250312.0036\",\n  \"@context\": \"https://raw.githubusercontent.com/dandi/schema/master/releases/0.6.9/context.json\",\n  \"citation\": \"Klein, Peter (2025) Hippocampal neuronal responses to programmable antigen-gated G-protein-coupled engineered receptor activation (Version 0.250312.0036) [Data set]. DANDI Archive. https://doi.org/10.48324/dandi.001354/0.250312.0036\",\n  \"keywords\": [\n    \"CA1\",\n    \"PAGER\",\n    \"Chemogenetics\",\n    \"Antigen-gated\"\n  ],\n  \"protocol\": [\n    \"https://doi.org/10.1038/s41586-024-08282-3\"\n  ],\n  \"schemaKey\": \"Dandiset\",\n  \"identifier\": \"DANDI:001354\",\n  \"repository\": \"https://dandiarchive.org\",\n  \"contributor\": [\n    {\n      \"name\": \"Klein, Peter\",\n      \"email\": \"kleinp@stanford.edu\",\n      \"roleName\": [\n        \"dcite:ContactPerson\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"affiliation\": [],\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"National Institute of Mental Health\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"awardNumber\": \"1R01MH135934\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"Phil and Penny Knight Initiative for Brain Resilience\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"awardNumber\": \"KIG-104\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"National Cancer Institute\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"awardNumber\": \"F32CA257159\",\n      \"includeInCitation\": false\n    }\n  ],\n  \"dateCreated\": \"2025-03-06T01:32:11.648954+00:00\",\n  \"description\": \"This dataset contains single cell electrophysiological recordings of mouse hippocampal CA1 neurons in response to activation of programmable antigen-gated G-protein-coupled engineered receptors. Recorded neurons were transfected with an AAV1/2-hSyn-a-mCherry-PAGER-Gi-P2A-mEGFP and responses were then recorded in response to DCZ (100 nM) or DCZ + soluble mCherry (1 uM) application.\\n\\nThe authors are grateful to the St Jude Children\\u2019s Research Hospital Collaborative Research Consortium on GPCRs, the Chan Zuckerberg Biohub\\u2013San Francisco, Phil and Penny Knight Initiative for Brain Resilience (KIG-104), Stanford Cancer Institute, Wu Tsai Neurosciences Institute of Stanford University and the NIH (MH135934 to A.Y.T. and I.S., F32CA257159 to N.A.K., NS121106 to I.S.) for funding this work. R.T. was supported by the Life Sciences Research Foundation Fellowship (sponsored by Astellas Pharma) and JSPS Overseas Research Fellowship.\",\n  \"publishedBy\": {\n    \"id\": \"urn:uuid:0e8459e8-63c3-4770-bf55-154527ec08c1\",\n    \"name\": \"DANDI publish\",\n    \"endDate\": \"2025-03-12T00:36:29.554905+00:00\",\n    \"schemaKey\": \"PublishActivity\",\n    \"startDate\": \"2025-03-12T00:36:29.554905+00:00\",\n    \"wasAssociatedWith\": [\n      {\n        \"id\": \"urn:uuid:853ca711-3d9a-494a-989b-60c6ace9e25f\",\n        \"name\": \"DANDI API\",\n        \"version\": \"0.1.0\",\n        \"schemaKey\": \"Software\",\n        \"identifier\": \"RRID:SCR_017571\"\n      }\n    ]\n  },\n  \"studyTarget\": [\n    \"To validate the use of programmable antigen-gated G-protein-coupled engineered receptors to allow targeted modulation of neuronal activity.\"\n  ],\n  \"assetsSummary\": {\n    \"species\": [\n      {\n        \"name\": \"Mus musculus - House mouse\",\n        \"schemaKey\": \"SpeciesType\",\n        \"identifier\": \"http://purl.obolibrary.org/obo/NCBITaxon_10090\"\n      }\n    ],\n    \"approach\": [\n      {\n        \"name\": \"electrophysiological approach\",\n        \"schemaKey\": \"ApproachType\"\n      }\n    ],\n    \"schemaKey\": \"AssetsSummary\",\n    \"dataStandard\": [\n      {\n        \"name\": \"Neurodata Without Borders (NWB)\",\n        \"schemaKey\": \"StandardsType\",\n        \"identifier\": \"RRID:SCR_015242\"\n      }\n    ],\n    \"numberOfBytes\": 1676840284,\n    \"numberOfCells\": 50,\n    \"numberOfFiles\": 50,\n    \"numberOfSamples\": 50,\n    \"numberOfSubjects\": 8,\n    \"variableMeasured\": [\n      \"CurrentClampSeries\",\n      \"CurrentClampStimulusSeries\"\n    ],\n    \"measurementTechnique\": [\n      {\n        \"name\": \"current clamp technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      }\n    ]\n  },\n  \"datePublished\": \"2025-03-12T00:36:29.554905+00:00\",\n  \"schemaVersion\": \"0.6.9\",\n  \"ethicsApproval\": [],\n  \"wasGeneratedBy\": [],\n  \"acknowledgement\": \"The authors are grateful to the St Jude Children\\u2019s Research Hospital Collaborative Research Consortium on GPCRs, the Chan Zuckerberg Biohub\\u2013San Francisco, Phil and Penny Knight Initiative for Brain Resilience (KIG-104), Stanford Cancer Institute, Wu Tsai Neurosciences Institute of Stanford University and the NIH (MH135934 to A.Y.T. and I.S., F32CA257159 to N.A.K., NS121106 to I.S.) for funding this work. R.T. was supported by the Life Sciences Research Foundation Fellowship (sponsored by Astellas Pharma) and JSPS Overseas Research Fellowship.\",\n  \"relatedResource\": [\n    {\n      \"url\": \"https://www.nature.com/articles/s41586-024-08282-3\",\n      \"name\": \"Synthetic GPCRs for programmable sensing and control of cell behaviour\",\n      \"relation\": \"dcite:IsPublishedIn\",\n      \"schemaKey\": \"Resource\",\n      \"identifier\": \"https://doi.org/10.1038/s41586-024-08282-3\",\n      \"repository\": \"Nature\",\n      \"resourceType\": \"dcite:JournalArticle\"\n    }\n  ],\n  \"manifestLocation\": [\n    \"https://dandiarchive.s3.amazonaws.com/dandisets/001354/0.250312.0036/assets.yaml\"\n  ]\n}"
      }
    ]
  },
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is a listing of some of the files in the Dandiset."
      },
      {
        "type": "text",
        "text": "sub-PK-109/sub-PK-109_ses-20240717T180719_slice-2024-07-17-0009_cell-2024-07-17-0009_icephys.nwb\nsub-PK-109/sub-PK-109_ses-20240717T150830_slice-2024-07-17-0001_cell-2024-07-17-0001_icephys.nwb\nsub-PK-109/sub-PK-109_ses-20240717T184616_slice-2024-07-17-0011_cell-2024-07-17-0011_icephys.nwb\nsub-PK-109/sub-PK-109_ses-20240717T164239_slice-2024-07-17-0005_cell-2024-07-17-0005_icephys.nwb\nsub-PK-109/sub-PK-109_ses-20240717T155714_slice-2024-07-17-0003_cell-2024-07-17-0003_icephys.nwb\nsub-PK-110/sub-PK-110_ses-20240723T173444_slice-2024-07-23-0010_cell-2024-07-23-0010_icephys.nwb\nsub-PK-110/sub-PK-110_ses-20240723T195515_slice-2024-07-23-0017_cell-2024-07-23-0017_icephys.nwb\nsub-PK-110/sub-PK-110_ses-20240723T143352_slice-2024-07-23-0003_cell-2024-07-23-0003_icephys.nwb\nsub-PK-110/sub-PK-110_ses-20240723T185020_slice-2024-07-23-0014_cell-2024-07-23-0014_icephys.nwb\nsub-PK-110/sub-PK-110_ses-20240723T160020_slice-2024-07-23-0006_cell-2024-07-23-0006_icephys.nwb"
      }
    ]
  },
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is metadata and usage information about the file sub-PK-109/sub-PK-109_ses-20240717T180719_slice-2024-07-17-0009_cell-2024-07-17-0009_icephys.nwb."
      },
      {
        "type": "text",
        "text": "\nimport pynwb\nimport h5py\nimport remfile\n\n# Load\nfrom dandi.dandiapi import DandiAPIClient\n\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(\"001354\", \"0.250312.0036\")\nurl = next(dandiset.get_assets_by_glob(\"sub-PK-109/sub-PK-109_ses-20240717T180719_slice-2024-07-17-0009_cell-2024-07-17-0009_icephys.nwb\")).download_url\n\nremote_file = remfile.File(url)\nh5_file = h5py.File(remote_file)\nio = pynwb.NWBHDF5IO(file=h5_file)\nnwb = io.read()\n\nnwb # (NWBFile)\nnwb.session_description # (str) Intracellular electrophysiology experiment.\nnwb.identifier # (str) pk2024_07_17_0009\nnwb.session_start_time # (datetime) 2024-07-17T18:07:19-07:00\nnwb.timestamps_reference_time # (datetime) 2024-07-17T18:07:19-07:00\nnwb.file_create_date # (list) [datetime.datetime(2025, 3, 7, 17, 42, 47, 161274, tzinfo=tzoffset(None, -28800))]\nnwb.experimenter # (tuple) ['_']\nnwb.icephys_electrodes # (LabelledDict)\nicephys_electrodes = nwb.icephys_electrodes\nelectrode_0 = icephys_electrodes[\"electrode-0\"]\nelectrode_0 # (IntracellularElectrode)\nelectrode_0.description # (str) no description\nelectrode_0.device # (Device)\nelectrode_0.device.description # (str) no description\nelectrode_1 = icephys_electrodes[\"electrode-1\"]\nelectrode_1 # (IntracellularElectrode)\nelectrode_1.description # (str) no description\nelectrode_1.device # (Device)\nelectrode_1.device.description # (str) no description\nnwb.acquisition # (LabelledDict)\nacquisition = nwb.acquisition\ncurrent_clamp_response_01_ch_0 = acquisition[\"current_clamp-response-01-ch-0\"]\ncurrent_clamp_response_01_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_01_ch_0.starting_time # (float64) 0.0\ncurrent_clamp_response_01_ch_0.rate # (float64) 20000.0\ncurrent_clamp_response_01_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_01_ch_0.comments # (str) no comments\ncurrent_clamp_response_01_ch_0.description # (str) Response to: ramp\ncurrent_clamp_response_01_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_01_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_01_ch_0.unit # (str) volts\ncurrent_clamp_response_01_ch_0.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_01_ch_0.data[:] # Access all data\n# current_clamp_response_01_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_01_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_01_ch_0.gain # (float64) nan\ncurrent_clamp_response_01_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_01_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_01_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_01_ch_0.electrode.device # (Device)\ncurrent_clamp_response_01_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_01_ch_1 = acquisition[\"current_clamp-response-01-ch-1\"]\ncurrent_clamp_response_01_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_01_ch_1.starting_time # (float64) 0.0\ncurrent_clamp_response_01_ch_1.rate # (float64) 20000.0\ncurrent_clamp_response_01_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_01_ch_1.comments # (str) no comments\ncurrent_clamp_response_01_ch_1.description # (str) Response to: ramp\ncurrent_clamp_response_01_ch_1.conversion # (float64) 1.2241307445453604e-13\ncurrent_clamp_response_01_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_01_ch_1.unit # (str) volts\ncurrent_clamp_response_01_ch_1.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_01_ch_1.data[:] # Access all data\n# current_clamp_response_01_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_01_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_01_ch_1.gain # (float64) nan\ncurrent_clamp_response_01_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_01_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_01_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_01_ch_1.electrode.device # (Device)\ncurrent_clamp_response_01_ch_1.electrode.device.description # (str) no description\ncurrent_clamp_response_02_ch_0 = acquisition[\"current_clamp-response-02-ch-0\"]\ncurrent_clamp_response_02_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_02_ch_0.starting_time # (float64) 5.0\ncurrent_clamp_response_02_ch_0.rate # (float64) 20000.0\ncurrent_clamp_response_02_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_02_ch_0.comments # (str) no comments\ncurrent_clamp_response_02_ch_0.description # (str) Response to: ramp\ncurrent_clamp_response_02_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_02_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_02_ch_0.unit # (str) volts\ncurrent_clamp_response_02_ch_0.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_02_ch_0.data[:] # Access all data\n# current_clamp_response_02_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_02_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_02_ch_0.gain # (float64) nan\ncurrent_clamp_response_02_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_02_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_02_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_02_ch_0.electrode.device # (Device)\ncurrent_clamp_response_02_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_02_ch_1 = acquisition[\"current_clamp-response-02-ch-1\"]\ncurrent_clamp_response_02_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_02_ch_1.starting_time # (float64) 5.0\ncurrent_clamp_response_02_ch_1.rate # (float64) 20000.0\ncurrent_clamp_response_02_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_02_ch_1.comments # (str) no comments\ncurrent_clamp_response_02_ch_1.description # (str) Response to: ramp\ncurrent_clamp_response_02_ch_1.conversion # (float64) 1.2241307445453604e-13\ncurrent_clamp_response_02_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_02_ch_1.unit # (str) volts\ncurrent_clamp_response_02_ch_1.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_02_ch_1.data[:] # Access all data\n# current_clamp_response_02_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_02_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_02_ch_1.gain # (float64) nan\ncurrent_clamp_response_02_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_02_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_02_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_02_ch_1.electrode.device # (Device)\ncurrent_clamp_response_02_ch_1.electrode.device.description # (str) no description\ncurrent_clamp_response_03_ch_0 = acquisition[\"current_clamp-response-03-ch-0\"]\ncurrent_clamp_response_03_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_03_ch_0.starting_time # (float64) 10.0\ncurrent_clamp_response_03_ch_0.rate # (float64) 20000.0\ncurrent_clamp_response_03_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_03_ch_0.comments # (str) no comments\ncurrent_clamp_response_03_ch_0.description # (str) Response to: ramp\ncurrent_clamp_response_03_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_03_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_03_ch_0.unit # (str) volts\ncurrent_clamp_response_03_ch_0.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_03_ch_0.data[:] # Access all data\n# current_clamp_response_03_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_03_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_03_ch_0.gain # (float64) nan\ncurrent_clamp_response_03_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_03_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_03_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_03_ch_0.electrode.device # (Device)\ncurrent_clamp_response_03_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_03_ch_1 = acquisition[\"current_clamp-response-03-ch-1\"]\ncurrent_clamp_response_03_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_03_ch_1.starting_time # (float64) 10.0\ncurrent_clamp_response_03_ch_1.rate # (float64) 20000.0\ncurrent_clamp_response_03_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_03_ch_1.comments # (str) no comments\ncurrent_clamp_response_03_ch_1.description # (str) Response to: ramp\ncurrent_clamp_response_03_ch_1.conversion # (float64) 1.2241307445453604e-13\ncurrent_clamp_response_03_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_03_ch_1.unit # (str) volts\ncurrent_clamp_response_03_ch_1.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_03_ch_1.data[:] # Access all data\n# current_clamp_response_03_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_03_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_03_ch_1.gain # (float64) nan\ncurrent_clamp_response_03_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_03_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_03_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_03_ch_1.electrode.device # (Device)\ncurrent_clamp_response_03_ch_1.electrode.device.description # (str) no description\ncurrent_clamp_response_04_ch_0 = acquisition[\"current_clamp-response-04-ch-0\"]\ncurrent_clamp_response_04_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_04_ch_0.starting_time # (float64) 15.0\ncurrent_clamp_response_04_ch_0.rate # (float64) 20000.0\ncurrent_clamp_response_04_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_04_ch_0.comments # (str) no comments\ncurrent_clamp_response_04_ch_0.description # (str) Response to: ramp\ncurrent_clamp_response_04_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_04_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_04_ch_0.unit # (str) volts\ncurrent_clamp_response_04_ch_0.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_04_ch_0.data[:] # Access all data\n# current_clamp_response_04_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_04_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_04_ch_0.gain # (float64) nan\ncurrent_clamp_response_04_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_04_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_04_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_04_ch_0.electrode.device # (Device)\ncurrent_clamp_response_04_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_04_ch_1 = acquisition[\"current_clamp-response-04-ch-1\"]\ncurrent_clamp_response_04_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_04_ch_1.starting_time # (float64) 15.0\ncurrent_clamp_response_04_ch_1.rate # (float64) 20000.0\ncurrent_clamp_response_04_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_04_ch_1.comments # (str) no comments\ncurrent_clamp_response_04_ch_1.description # (str) Response to: ramp\ncurrent_clamp_response_04_ch_1.conversion # (float64) 1.2241307445453604e-13\ncurrent_clamp_response_04_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_04_ch_1.unit # (str) volts\ncurrent_clamp_response_04_ch_1.data # (Dataset) shape (100000,); dtype int16\n# current_clamp_response_04_ch_1.data[:] # Access all data\n# current_clamp_response_04_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_04_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_04_ch_1.gain # (float64) nan\ncurrent_clamp_response_04_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_04_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_04_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_04_ch_1.electrode.device # (Device)\ncurrent_clamp_response_04_ch_1.electrode.device.description # (str) no description\n# ...\n# Other fields: current_clamp-response-05-ch-0, current_clamp-response-05-ch-1, current_clamp-response-06-ch-0, current_clamp-response-06-ch-1, current_clamp-response-07-ch-0, current_clamp-response-07-ch-1, current_clamp-response-08-ch-0, current_clamp-response-08-ch-1, current_clamp-response-09-ch-0, current_clamp-response-09-ch-1, current_clamp-response-10-ch-0, current_clamp-response-10-ch-1, current_clamp-response-100-ch-0, current_clamp-response-100-ch-1, current_clamp-response-101-ch-0\n# ... and 601 more fields\nnwb.stimulus # (LabelledDict)\nstimulus = nwb.stimulus\nstimulus_01_ch_0 = stimulus[\"stimulus-01-ch-0\"]\nstimulus_01_ch_0 # (CurrentClampStimulusSeries)\nstimulus_01_ch_0.starting_time # (float64) 0.0\nstimulus_01_ch_0.rate # (float64) 20000.0\nstimulus_01_ch_0.resolution # (float64) -1.0\nstimulus_01_ch_0.comments # (str) no comments\nstimulus_01_ch_0.description # (str) Stim type: ramp\nstimulus_01_ch_0.conversion # (float64) 1e-12\nstimulus_01_ch_0.offset # (float64) 0.0\nstimulus_01_ch_0.unit # (str) amperes\nstimulus_01_ch_0.data # (Dataset) shape (100000,); dtype float64\n# stimulus_01_ch_0.data[:] # Access all data\n# stimulus_01_ch_0.data[0:n] # Access first n elements\nstimulus_01_ch_0.starting_time_unit # (str) seconds\nstimulus_01_ch_0.gain # (float64) nan\nstimulus_01_ch_0.stimulus_description # (str) N/A\nstimulus_01_ch_0.electrode # (IntracellularElectrode)\nstimulus_01_ch_0.electrode.description # (str) no description\nstimulus_01_ch_0.electrode.device # (Device)\nstimulus_01_ch_0.electrode.device.description # (str) no description\nstimulus_01_ch_1 = stimulus[\"stimulus-01-ch-1\"]\nstimulus_01_ch_1 # (CurrentClampStimulusSeries)\nstimulus_01_ch_1.starting_time # (float64) 0.0\nstimulus_01_ch_1.rate # (float64) 20000.0\nstimulus_01_ch_1.resolution # (float64) -1.0\nstimulus_01_ch_1.comments # (str) no comments\nstimulus_01_ch_1.description # (str) Stim type: ramp\nstimulus_01_ch_1.conversion # (float64) 1e-12\nstimulus_01_ch_1.offset # (float64) 0.0\nstimulus_01_ch_1.unit # (str) amperes\nstimulus_01_ch_1.data # (Dataset) shape (100000,); dtype float64\n# stimulus_01_ch_1.data[:] # Access all data\n# stimulus_01_ch_1.data[0:n] # Access first n elements\nstimulus_01_ch_1.starting_time_unit # (str) seconds\nstimulus_01_ch_1.gain # (float64) nan\nstimulus_01_ch_1.stimulus_description # (str) N/A\nstimulus_01_ch_1.electrode # (IntracellularElectrode)\nstimulus_01_ch_1.electrode.description # (str) no description\nstimulus_01_ch_1.electrode.device # (Device)\nstimulus_01_ch_1.electrode.device.description # (str) no description\nstimulus_02_ch_0 = stimulus[\"stimulus-02-ch-0\"]\nstimulus_02_ch_0 # (CurrentClampStimulusSeries)\nstimulus_02_ch_0.starting_time # (float64) 5.0\nstimulus_02_ch_0.rate # (float64) 20000.0\nstimulus_02_ch_0.resolution # (float64) -1.0\nstimulus_02_ch_0.comments # (str) no comments\nstimulus_02_ch_0.description # (str) Stim type: ramp\nstimulus_02_ch_0.conversion # (float64) 1e-12\nstimulus_02_ch_0.offset # (float64) 0.0\nstimulus_02_ch_0.unit # (str) amperes\nstimulus_02_ch_0.data # (Dataset) shape (100000,); dtype float64\n# stimulus_02_ch_0.data[:] # Access all data\n# stimulus_02_ch_0.data[0:n] # Access first n elements\nstimulus_02_ch_0.starting_time_unit # (str) seconds\nstimulus_02_ch_0.gain # (float64) nan\nstimulus_02_ch_0.stimulus_description # (str) N/A\nstimulus_02_ch_0.electrode # (IntracellularElectrode)\nstimulus_02_ch_0.electrode.description # (str) no description\nstimulus_02_ch_0.electrode.device # (Device)\nstimulus_02_ch_0.electrode.device.description # (str) no description\nstimulus_02_ch_1 = stimulus[\"stimulus-02-ch-1\"]\nstimulus_02_ch_1 # (CurrentClampStimulusSeries)\nstimulus_02_ch_1.starting_time # (float64) 5.0\nstimulus_02_ch_1.rate # (float64) 20000.0\nstimulus_02_ch_1.resolution # (float64) -1.0\nstimulus_02_ch_1.comments # (str) no comments\nstimulus_02_ch_1.description # (str) Stim type: ramp\nstimulus_02_ch_1.conversion # (float64) 1e-12\nstimulus_02_ch_1.offset # (float64) 0.0\nstimulus_02_ch_1.unit # (str) amperes\nstimulus_02_ch_1.data # (Dataset) shape (100000,); dtype float64\n# stimulus_02_ch_1.data[:] # Access all data\n# stimulus_02_ch_1.data[0:n] # Access first n elements\nstimulus_02_ch_1.starting_time_unit # (str) seconds\nstimulus_02_ch_1.gain # (float64) nan\nstimulus_02_ch_1.stimulus_description # (str) N/A\nstimulus_02_ch_1.electrode # (IntracellularElectrode)\nstimulus_02_ch_1.electrode.description # (str) no description\nstimulus_02_ch_1.electrode.device # (Device)\nstimulus_02_ch_1.electrode.device.description # (str) no description\nstimulus_03_ch_0 = stimulus[\"stimulus-03-ch-0\"]\nstimulus_03_ch_0 # (CurrentClampStimulusSeries)\nstimulus_03_ch_0.starting_time # (float64) 10.0\nstimulus_03_ch_0.rate # (float64) 20000.0\nstimulus_03_ch_0.resolution # (float64) -1.0\nstimulus_03_ch_0.comments # (str) no comments\nstimulus_03_ch_0.description # (str) Stim type: ramp\nstimulus_03_ch_0.conversion # (float64) 1e-12\nstimulus_03_ch_0.offset # (float64) 0.0\nstimulus_03_ch_0.unit # (str) amperes\nstimulus_03_ch_0.data # (Dataset) shape (100000,); dtype float64\n# stimulus_03_ch_0.data[:] # Access all data\n# stimulus_03_ch_0.data[0:n] # Access first n elements\nstimulus_03_ch_0.starting_time_unit # (str) seconds\nstimulus_03_ch_0.gain # (float64) nan\nstimulus_03_ch_0.stimulus_description # (str) N/A\nstimulus_03_ch_0.electrode # (IntracellularElectrode)\nstimulus_03_ch_0.electrode.description # (str) no description\nstimulus_03_ch_0.electrode.device # (Device)\nstimulus_03_ch_0.electrode.device.description # (str) no description\nstimulus_03_ch_1 = stimulus[\"stimulus-03-ch-1\"]\nstimulus_03_ch_1 # (CurrentClampStimulusSeries)\nstimulus_03_ch_1.starting_time # (float64) 10.0\nstimulus_03_ch_1.rate # (float64) 20000.0\nstimulus_03_ch_1.resolution # (float64) -1.0\nstimulus_03_ch_1.comments # (str) no comments\nstimulus_03_ch_1.description # (str) Stim type: ramp\nstimulus_03_ch_1.conversion # (float64) 1e-12\nstimulus_03_ch_1.offset # (float64) 0.0\nstimulus_03_ch_1.unit # (str) amperes\nstimulus_03_ch_1.data # (Dataset) shape (100000,); dtype float64\n# stimulus_03_ch_1.data[:] # Access all data\n# stimulus_03_ch_1.data[0:n] # Access first n elements\nstimulus_03_ch_1.starting_time_unit # (str) seconds\nstimulus_03_ch_1.gain # (float64) nan\nstimulus_03_ch_1.stimulus_description # (str) N/A\nstimulus_03_ch_1.electrode # (IntracellularElectrode)\nstimulus_03_ch_1.electrode.description # (str) no description\nstimulus_03_ch_1.electrode.device # (Device)\nstimulus_03_ch_1.electrode.device.description # (str) no description\nstimulus_04_ch_0 = stimulus[\"stimulus-04-ch-0\"]\nstimulus_04_ch_0 # (CurrentClampStimulusSeries)\nstimulus_04_ch_0.starting_time # (float64) 15.0\nstimulus_04_ch_0.rate # (float64) 20000.0\nstimulus_04_ch_0.resolution # (float64) -1.0\nstimulus_04_ch_0.comments # (str) no comments\nstimulus_04_ch_0.description # (str) Stim type: ramp\nstimulus_04_ch_0.conversion # (float64) 1e-12\nstimulus_04_ch_0.offset # (float64) 0.0\nstimulus_04_ch_0.unit # (str) amperes\nstimulus_04_ch_0.data # (Dataset) shape (100000,); dtype float64\n# stimulus_04_ch_0.data[:] # Access all data\n# stimulus_04_ch_0.data[0:n] # Access first n elements\nstimulus_04_ch_0.starting_time_unit # (str) seconds\nstimulus_04_ch_0.gain # (float64) nan\nstimulus_04_ch_0.stimulus_description # (str) N/A\nstimulus_04_ch_0.electrode # (IntracellularElectrode)\nstimulus_04_ch_0.electrode.description # (str) no description\nstimulus_04_ch_0.electrode.device # (Device)\nstimulus_04_ch_0.electrode.device.description # (str) no description\nstimulus_04_ch_1 = stimulus[\"stimulus-04-ch-1\"]\nstimulus_04_ch_1 # (CurrentClampStimulusSeries)\nstimulus_04_ch_1.starting_time # (float64) 15.0\nstimulus_04_ch_1.rate # (float64) 20000.0\nstimulus_04_ch_1.resolution # (float64) -1.0\nstimulus_04_ch_1.comments # (str) no comments\nstimulus_04_ch_1.description # (str) Stim type: ramp\nstimulus_04_ch_1.conversion # (float64) 1e-12\nstimulus_04_ch_1.offset # (float64) 0.0\nstimulus_04_ch_1.unit # (str) amperes\nstimulus_04_ch_1.data # (Dataset) shape (100000,); dtype float64\n# stimulus_04_ch_1.data[:] # Access all data\n# stimulus_04_ch_1.data[0:n] # Access first n elements\nstimulus_04_ch_1.starting_time_unit # (str) seconds\nstimulus_04_ch_1.gain # (float64) nan\nstimulus_04_ch_1.stimulus_description # (str) N/A\nstimulus_04_ch_1.electrode # (IntracellularElectrode)\nstimulus_04_ch_1.electrode.description # (str) no description\nstimulus_04_ch_1.electrode.device # (Device)\nstimulus_04_ch_1.electrode.device.description # (str) no description\n# ...\n# Other fields: stimulus-05-ch-0, stimulus-05-ch-1, stimulus-06-ch-0, stimulus-06-ch-1, stimulus-07-ch-0, stimulus-07-ch-1, stimulus-08-ch-0, stimulus-08-ch-1, stimulus-09-ch-0, stimulus-09-ch-1, stimulus-10-ch-0, stimulus-10-ch-1, stimulus-100-ch-0, stimulus-100-ch-1, stimulus-101-ch-0\n# ... and 601 more fields\nnwb.devices # (LabelledDict)\ndevices = nwb.devices\nDeviceIcephys = devices[\"DeviceIcephys\"]\nDeviceIcephys # (Device)\nDeviceIcephys.description # (str) no description\nnwb.lab_meta_data # (LabelledDict)\nlab_meta_data = nwb.lab_meta_data\nDandiIcephysMetadata = lab_meta_data[\"DandiIcephysMetadata\"]\nDandiIcephysMetadata # (DandiIcephysMetadata)\nDandiIcephysMetadata.cell_id # (str) 2024_07_17_0009\nDandiIcephysMetadata.slice_id # (str) 2024_07_17_0009\nDandiIcephysMetadata.targeted_layer # (str) CA1\nDandiIcephysMetadata.inferred_layer # (str) \nnwb.lab # (str) _\nnwb.institution # (str) _\nnwb.source_script # (str) Created using NeuroConv v0.7.1\nnwb.source_script_file_name # (str) C:\\Users\\pklei\\anaconda3\\Lib\\site-packages\\neuroconv\\basedatainterface.py\nnwb.subject # (Subject)\nnwb.subject.age__reference # (str) birth\nnwb.subject.sex # (str) F\nnwb.subject.species # (str) Mus musculus\nnwb.subject.subject_id # (str) PK-109\nnwb.subject.date_of_birth # (datetime) 2024-04-07T00:00:00-07:00\nnwb.intracellular_recordings # (IntracellularRecordingsTable)\nnwb.intracellular_recordings.description # (str) A table to group together a stimulus and response from a single electrode and a single simultaneo...\nnwb.intracellular_recordings.colnames # (tuple) []\nnwb.intracellular_recordings.columns # (tuple) []\nnwb.intracellular_recordings.category_tables # (OrderedDict)\nnwb.intracellular_recordings.id # (ElementIdentifiers)\n# nwb.intracellular_recordings.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 624 rows and 0 columns\n# nwb.intracellular_recordings.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.icephys_simultaneous_recordings # (SimultaneousRecordingsTable)\nnwb.icephys_simultaneous_recordings.description # (str) A table for grouping different intracellular recordings from theIntracellularRecordingsTable tabl...\nnwb.icephys_simultaneous_recordings.colnames # (tuple) ['recordings']\nnwb.icephys_simultaneous_recordings.columns # (tuple)\nnwb.icephys_simultaneous_recordings.id # (ElementIdentifiers)\n# nwb.icephys_simultaneous_recordings.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 312 rows and 2 columns\n# nwb.icephys_simultaneous_recordings.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.icephys_simultaneous_recordings.recordings # (VectorIndex) Index for VectorData 'recordings'\n# nwb.icephys_simultaneous_recordings.recordings_index[0] # (DataFrame)\n# nwb.icephys_simultaneous_recordings.recordings_index[1] # (DataFrame)\n# nwb.icephys_simultaneous_recordings.recordings_index[2] # (DataFrame)\n# nwb.icephys_simultaneous_recordings.recordings_index[3] # (DataFrame)\n# ...\nnwb.icephys_sequential_recordings # (SequentialRecordingsTable)\nnwb.icephys_sequential_recordings.description # (str) A table for grouping different intracellular recording simultaneous_recordings from the Simultane...\nnwb.icephys_sequential_recordings.colnames # (tuple) ['simultaneous_recordings', 'stimulus_type']\nnwb.icephys_sequential_recordings.columns # (tuple)\nnwb.icephys_sequential_recordings.id # (ElementIdentifiers)\n# nwb.icephys_sequential_recordings.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 1 rows and 3 columns\n# nwb.icephys_sequential_recordings.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.icephys_sequential_recordings.simultaneous_recordings # (VectorIndex) Index for VectorData 'simultaneous_recordings'\n# nwb.icephys_sequential_recordings.simultaneous_recordings_index[0] # (DataFrame)\nnwb.icephys_sequential_recordings.stimulus_type # (VectorData) Column storing the type of stimulus used for the sequential recording"
      }
    ]
  },
  {
    "role": "user",
    "content": "On the basis of the above information, please create a jupytext notebook that introduces dandiset 001354 using the format described below.\n\nThe purpose of the notebook is to help researchers explore the dandiset and get started with a reanalysis.\n\nStart with an appropriate title for the notebook, such as \"Exploring Dandiset 001354: ...\" (that should be a markdown heading).\n\nInform the user that the notebook was generated with the assistance of AI, and that they should be cautious when interpreting the code or results.\n\nProvide an overview of the Dandiset. Include a link to the Dandiset of the form https://dandiarchive.org/dandiset/001354/0.250312.0036.\n\nSummarize what the notebook covers.\n\nList the packages that are required to run the notebook. Assume that these are already installed on the user's system. Do not include any pip install commands in the notebook.\n\nShow how to use the DANDI API to load assets.\n\nShow how to load and visualize data from the dandiset based on the above information. Feel free to organize things differently from how they are in the above information, but do not make up new information.\n\nGenerate good quality plots (without being redundant).\n\nLoad NWB data by streaming the remote file (as done in the above information) rather than downloading it.\n\nDo not use any functionality of pynwb or dandi that is not covered in the above information.\n\nYou should stick to material that is covered in the above information and do not hallucinate.\n\nThroughout the notebook, include explanatory markdown cells that guide the user through the process.\n\nThe notebook should be well-documented, and follow best practices Include comments in code cells to explain what each step does.\n\nThe Jupytext should use `# %% [markdown]` for markdown cells and `# %%` delimiters for the code cells.\n\nIf any NWB have units objects, you should know the following:\nunits.spike_times_index[i] provides the vector of spike times for the i^th unit. It is actually not an index. Do not use units.spike_times.\n\nYour notebook will be evaluated based on the following criteria:\n1. How well did the notebook help you understand the purpose and content of the Dandiset?\n2. After reviewing the notebook, do you feel confident in how to access the different types of data from this Dandiset?\n3. Did the notebook help you understand the structure of the NWB file(s) and how to work with them?\n4. Did the visualizations in the notebook generally help you understand key aspects of the data?\n5. Did any of the visualizations make it harder to understand the data (e.g., due to poor formatting, unclear axes, or misleading displays)?\n6. Do you feel more confident creating your own visualizations of the data after seeing the examples in the notebook?\n7. How well did the visualizations show the structure or complexity of the data?\n8. Were there any interpretations or conclusions in the notebook that felt unclear or not well supported by the data shown?\n9. Did any of the plots or examples feel unnecessarily repetitive or redundant?\n10. Did the notebook help you understand what kinds of questions or analyses you could do next with this Dandiset?\n11. How clear and easy was the notebook to follow?\n12. Did the notebook provide code you could easily reuse or adapt to explore the Dandiset yourself?\n13. Did the notebook help you understand what kinds of questions or analyses you could do next with this Dandiset?\n14. Overall, how helpful was this notebook for getting started with this Dandiset?\n\nYour output should be in the format:\n\n<notebook>\nThe text of the jupytext notebook should appear here.\n</notebook>\n\nNo other text should be included in the response.\n"
  },
  {
    "role": "assistant",
    "content": "<notebook>\n# %% [markdown]\n# # Exploring Dandiset 001354: Hippocampal Neuronal Responses to Programmable Antigen-Gated GPCR Activation\n#\n# *Notebook generated with the assistance of AI. Please be cautious in interpreting the code and results below, and always validate outputs for your research needs.*\n\n# %% [markdown]\n# ## Overview\n#\n# This notebook introduces [Dandiset 001354 (Version 0.250312.0036)](https://dandiarchive.org/dandiset/001354/0.250312.0036), entitled **\"Hippocampal neuronal responses to programmable antigen-gated G-protein-coupled engineered receptor activation\"**.\n#\n# This dataset contains single cell electrophysiological recordings from mouse hippocampal CA1 neurons, captured in response to activation of programmable antigen-gated G-protein-coupled engineered receptors (PAGERs). The primary experimental aim is to validate the use of programmable antigen-gated GPCRs to allow targeted modulation of neuronal activity.\n#\n# The data are provided in the [Neurodata Without Borders (NWB)](https://www.nwb.org/) format, including per-cell voltage responses under various current clamp protocols, with metadata on cell identity and experimental context.\n\n# %% [markdown]\n# ## What This Notebook Covers\n#\n# * Brief summary of Dandiset 001354 and its experimental focus.\n# * Guidance on accessing and inspecting data assets with the DANDI API.\n# * Code for remote streaming and inspection of NWB files.\n# * Visualization of key electrophysiology data such as:\n#     * Current clamp response traces to ramp stimuli\n#     * Associated stimulus profiles\n# * Explanation of how the data is organized within the NWB structure.\n#\n# By the end of this notebook, you should feel confident how to:\n# * List and select datasets in this Dandiset programmatically\n# * Load NWB-format intracellular electrophysiology data by streaming\n# * Visualize raw and stimulus data for one or more cells\n# * Understand the mapping between metadata and data arrays\n\n# %% [markdown]\n# ## Required Python Packages\n#\n# This notebook requires the following packages (assumed pre-installed):\n#\n# * `dandi` \u2014 for DANDI Archive API queries\n# * `remfile` \u2014 for remote file streaming\n# * `h5py` \u2014 for HDF5/NWB file access from remote streams\n# * `pynwb` \u2014 for NWB format parsing\n# * `matplotlib` \u2014 for data visualization\n# * `numpy` \u2014 for numerical processing\n#\n# If any are missing, please install them using your package manager before running.\n\n# %% [markdown]\n# ## 1. Explore Available Data Assets with the DANDI API\n\n# %%\nfrom dandi.dandiapi import DandiAPIClient\n\n# Initialize API client and select the Dandiset/version of interest\ndandiset_id = \"001354\"\ndandiset_version = \"0.250312.0036\"\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(dandiset_id, dandiset_version)\n\n# List a few assets in the Dandiset (limit for display)\nprint(f\"Listing a subset of files available in Dandiset {dandiset_id}:\")\nfor i, asset in enumerate(dandiset.get_assets()):\n    print(\"-\", asset.path)\n    if i >= 9:  # Display up to 10 files\n        print(\"...\")\n        break\n\n# %% [markdown]\n# The Dandiset consists of NWB files for multiple cells (e.g., PK-109, PK-110) and sessions.\n# Each NWB file contains intracellular recordings, metadata, stimulus, and response traces for a single cell.\n\n# %% [markdown]\n# ## 2. Selecting & Streaming an NWB File for Inspection\n#\n# We demonstrate with one file (`sub-PK-109/sub-PK-109_ses-20240717T180719_slice-2024-07-17-0009_cell-2024-07-17-0009_icephys.nwb`), representing a single cell from mouse PK-109.\n#\n# Data is streamed directly from the DANDI Archive using `remfile` and opened with `h5py` and `pynwb`, so the file is not fully downloaded.\n\n# %%\nimport remfile\nimport h5py\nimport pynwb\n\n# Choose a file of interest (demonstration \u2014 you can change this to any in the dandiset)\nnwb_relative_path = \"sub-PK-109/sub-PK-109_ses-20240717T180719_slice-2024-07-17-0009_cell-2024-07-17-0009_icephys.nwb\"\n\n# Get the download URL for remote streaming\nasset = next(dandiset.get_assets_by_glob(nwb_relative_path))\nnwb_url = asset.download_url\n\n# Stream open the file using remfile, and load into pynwb via h5py\nremote_file = remfile.File(nwb_url)\nh5_file = h5py.File(remote_file)\nio = pynwb.NWBHDF5IO(file=h5_file)\nnwb = io.read()\n\nprint(f\"NWBFile identifier: {nwb.identifier}\")\nprint(f\"Session start: {nwb.session_start_time}\")\nprint(f\"Subject: {nwb.subject.subject_id}, Species: {nwb.subject.species}\")\n\n# %% [markdown]\n# ## 3. Inspecting the NWB File Structure\n\n# %%\n# Print summary fields to show what data is available\nprint(\"Available acquisition (response) series:\")\nprint(list(nwb.acquisition.keys())[:10], \"...\")\n\nprint(\"\\nAvailable stimulus series:\")\nprint(list(nwb.stimulus.keys())[:10], \"...\")\n\nprint(\"\\nNumber of current clamp response traces:\", len(nwb.acquisition))\nprint(\"Number of stimulus traces:\", len(nwb.stimulus))\n\n# Show subject and cell metadata\nsubject = nwb.subject\nprint(\"\\nSubject info:\")\nprint(\"  subject_id:\", subject.subject_id)\nprint(\"  age (reference):\", getattr(subject, \"age__reference\", None))\nprint(\"  sex:\", subject.sex)\nprint(\"  date_of_birth:\", getattr(subject, \"date_of_birth\", None))\n\ncell_md = nwb.lab_meta_data[\"DandiIcephysMetadata\"]\nprint(\"\\nCell metadata:\")\nprint(\"  targeted_layer:\", cell_md.targeted_layer)\nprint(\"  cell_id:\", cell_md.cell_id)\nprint(\"  slice_id:\", cell_md.slice_id)\n\n# %% [markdown]\n# The structure contains many stimulus/response pairs (numbered sequentially). Each pair shares a time base and is recorded at 20 kHz. \n#\n# The **acquisition group** holds the response traces (typically membrane potential, in volts), and **stimulus group** holds the input current (in amperes) delivered.\n\n# %% [markdown]\n# ## 4. Visualizing a Single Stimulus-Response Pair\n#\n# We'll examine the first ramp stimulus/response pair: `stimulus-01-ch-0` and `current_clamp-response-01-ch-0`.\n\n# %%\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Pick a channel (e.g., electrode 0, trial 1)\nresp = nwb.acquisition[\"current_clamp-response-01-ch-0\"]\nstim = nwb.stimulus[\"stimulus-01-ch-0\"]\n\n# Get conversion factor and data\n# Note: resp.data is int16, use conversion for volts; stim.data is float64 pA, conversion for amperes\nresp_data = resp.data[:].astype(np.float64) * resp.conversion\nstim_data = stim.data[:].astype(np.float64) * stim.conversion\nfs = resp.rate  # Sampling frequency (Hz)\nt = np.arange(resp_data.size) / fs + resp.starting_time  # Time axis (seconds)\n\n# Plot traces\nfig, (ax1, ax2) = plt.subplots(2, 1, sharex=True, figsize=(10, 5))\nax1.plot(t, stim_data * 1e12)  # Display in pA for clarity\nax1.set_ylabel(\"Current (pA)\")\nax1.set_title(\"Stimulus: Current Clamp (Ramp)\")\nax1.grid(True)\n\nax2.plot(t, resp_data * 1e3)  # Display in mV for clarity\nax2.set_ylabel(\"Voltage (mV)\")\nax2.set_xlabel(\"Time (s)\")\nax2.set_title(\"Response: Membrane Potential\")\nax2.grid(True)\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# **Explanation:**\n# - Top: the injected current ramp (in pA) delivered to the cell.\n# - Bottom: the measured membrane voltage response (in mV).\n# \n# Both traces are shown for the same duration and sample count; this facilitates comparison of how the neuron responds to input currents.\n\n# %% [markdown]\n# ## 5. Exploring Multiple Trials\n#\n# Typically, NWB files in this Dandiset contain >600 pairs of stimulus/response traces, often involving different currents or trial types (but here all labeled as `ramp`). Let's view several consecutive stimulus-response pairs to get a sense of response consistency.\n\n# %%\nnum_trials = 4  # Number of consecutive ramp trials to display\n\nfig, axs = plt.subplots(num_trials, 2, figsize=(12, num_trials * 2.2), sharex=True)\nfor trial in range(1, num_trials + 1):\n    resp_key = f\"current_clamp-response-{trial:02d}-ch-0\"\n    stim_key = f\"stimulus-{trial:02d}-ch-0\"\n    resp = nwb.acquisition[resp_key]\n    stim = nwb.stimulus[stim_key]\n    stim_data = stim.data[:] * stim.conversion\n    resp_data = resp.data[:] * resp.conversion\n    t = np.arange(resp_data.size) / fs + resp.starting_time\n    \n    axs[trial-1, 0].plot(t, stim_data * 1e12)\n    axs[trial-1, 0].set_ylabel(f\"Trial {trial}\\nCurrent (pA)\")\n    axs[trial-1, 0].grid(True)\n    axs[trial-1, 1].plot(t, resp_data * 1e3)\n    axs[trial-1, 1].set_ylabel(\"Voltage (mV)\")\n    axs[trial-1, 1].grid(True)\n    if trial == num_trials:\n        axs[trial-1, 1].set_xlabel(\"Time (s)\")\n        axs[trial-1, 0].set_xlabel(\"Time (s)\")\naxs[0,0].set_title(\"Stimulus (Current Clamp)\")\naxs[0,1].set_title(\"Response (Membrane Voltage)\")\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# **Note:** The traces above illustrate stimulus and response for four consecutive trials from the same cell. The ramp shape and duration are highly reproducible, but cellular responses may evolve over time, reflecting changes in cell state or pharmacology.\n\n# %% [markdown]\n# ## 6. Understanding the Electrophysiological Metadata\n#\n# The NWB file contains additional tables for grouping and organizing the stim/resp recordings:\n# * `intracellular_recordings` table\n# * `icephys_simultaneous_recordings` table\n# * `icephys_sequential_recordings` table\n#\n# Let's briefly inspect the structure of these tables.\n\n# %%\nprint(\"intracellular_recordings: rows =\", len(nwb.intracellular_recordings.id))\nprint(\"icephys_simultaneous_recordings: rows =\", len(nwb.icephys_simultaneous_recordings.id))\nprint(\"icephys_sequential_recordings: rows =\", len(nwb.icephys_sequential_recordings.id))\nprint(\"Columns in sequential_recordings:\", nwb.icephys_sequential_recordings.colnames)\n\n# %% [markdown]\n# Although we do not further analyze these tables here, they are useful if you want to relate different trials, groupings, or stimulus types across experiments.\n\n# %% [markdown]\n# ## 7. What Next? Custom Analysis Ideas\n#\n# This notebook serves as a template for exploring Dandiset 001354. You can adapt it to:\n#\n# * Compare responses across cells, or between different experimental groups/sessions\n# * Examine effects of various antigens or drugs (by cross-referencing file-level or Dandiset-level metadata)\n# * Quantify properties such as input resistance, spike threshold, and firing rate from the traces\n# * Automatically batch process and plot across all files in the Dandiset for reproducibility\n#\n# See full protocol and experimental details at [the related publication](https://www.nature.com/articles/s41586-024-08282-3).\n\n# %% [markdown]\n# ## Summary\n# \n# * **Dandiset 001354** contains rich single-cell electrophysiology data for antigen-gated programmable GPCR activation in mouse hippocampal CA1.\n# * NWB files are well-structured for automated and manual exploration.\n# * Streaming access allows for inspection and visualization without full downloads.\n# * This notebook can be expanded for your own analyses; use and cite responsibly!\n</notebook>\n"
  }
]