[
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is metadata about Dandiset 001195 version 0.250408.1733."
      },
      {
        "type": "text",
        "text": "{\n  \"id\": \"DANDI:001195/0.250408.1733\",\n  \"doi\": \"10.48324/dandi.001195/0.250408.1733\",\n  \"url\": \"https://dandiarchive.org/dandiset/001195/0.250408.1733\",\n  \"name\": \"Separable Dorsal Raphe Dopamine Projections Mediate the Facets of Loneliness-like State\",\n  \"about\": [\n    {\n      \"name\": \"dorsal raphe nucleus (DRN)\",\n      \"schemaKey\": \"Anatomy\",\n      \"identifier\": \"UBERON:0001950\"\n    },\n    {\n      \"name\": \"Central Amygdala (CeA)\",\n      \"schemaKey\": \"Anatomy\",\n      \"identifier\": \"UBERON:0001876\"\n    },\n    {\n      \"name\": \"Bed Nucleus of the Stria Terminalis (BNST)\",\n      \"schemaKey\": \"Anatomy\",\n      \"identifier\": \"UBERON:0001880\"\n    },\n    {\n      \"name\": \"Posterior Basolateral Amygdala (BLP)\",\n      \"schemaKey\": \"Anatomy\",\n      \"identifier\": \"UBERON:0006107\"\n    },\n    {\n      \"name\": \"social isolation\",\n      \"schemaKey\": \"GenericType\",\n      \"identifier\": \"http://purl.obolibrary.org/obo/GSSO_003702\"\n    }\n  ],\n  \"access\": [\n    {\n      \"status\": \"dandi:OpenAccess\",\n      \"schemaKey\": \"AccessRequirements\"\n    }\n  ],\n  \"license\": [\n    \"spdx:CC-BY-4.0\"\n  ],\n  \"version\": \"0.250408.1733\",\n  \"@context\": \"https://raw.githubusercontent.com/dandi/schema/master/releases/0.6.8/context.json\",\n  \"citation\": \"Keyes, Laurel; Lee, Christopher R.; Wichmann, Romy; Matthews, Gillian A. ; Tye, Kay M.  (2025) Separable Dorsal Raphe Dopamine Projections Mediate the Facets of Loneliness-like State (Version 0.250408.1733) [Data set]. DANDI Archive. https://doi.org/10.48324/dandi.001195/0.250408.1733\",\n  \"keywords\": [\n    \"optogenetics\",\n    \"behavior videos\",\n    \"calcium imaging\",\n    \"electrophysiology\",\n    \"Social Isolation\",\n    \"Social Motivation\",\n    \"mouse behavior\",\n    \"behavioral neuroscience\",\n    \"mouse model\",\n    \"Dorsal Raphe Nucleus (DRN)\",\n    \"Dopamine neurons\"\n  ],\n  \"protocol\": [],\n  \"schemaKey\": \"Dandiset\",\n  \"identifier\": \"DANDI:001195\",\n  \"repository\": \"https://dandiarchive.org\",\n  \"contributor\": [\n    {\n      \"name\": \"Keyes, Laurel\",\n      \"email\": \"lkeyes@salk.edu\",\n      \"roleName\": [\n        \"dcite:ContactPerson\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0000-0001-5433-9948\",\n      \"affiliation\": [],\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"Lee, Christopher R.\",\n      \"email\": \"chrlee@salk.edu\",\n      \"roleName\": [\n        \"dcite:Author\",\n        \"dcite:Conceptualization\",\n        \"dcite:DataCollector\",\n        \"dcite:FormalAnalysis\",\n        \"dcite:Researcher\",\n        \"dcite:DataCurator\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"Wichmann, Romy\",\n      \"roleName\": [\n        \"dcite:Researcher\",\n        \"dcite:DataCurator\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0000-0002-4506-8813\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"Matthews, Gillian A. \",\n      \"roleName\": [\n        \"dcite:Author\",\n        \"dcite:Conceptualization\",\n        \"dcite:DataCollector\",\n        \"dcite:DataCurator\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"Tye, Kay M. \",\n      \"roleName\": [\n        \"dcite:Conceptualization\",\n        \"dcite:Supervision\",\n        \"dcite:Author\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0000-0002-2435-0182\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"The JPB Foundation\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/05nzwyq50\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"New York Stem Cell Foundation\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/03n2a3p06\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"Klingenstein Third Generation Foundation\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/00cxc2y95\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"McKnight Foundation\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/003ghvj67\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"Clayton Foundation\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/00qw4ms08\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"Alfred P Sloan Foundation\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/052csg198\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"National Institute of Mental Health\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/05xj56w78\",\n      \"awardNumber\": \"R01-MH115920\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"National Institute of Diabetes and Digestive and Kidney Diseases: NIH Director's New Innovator Award\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/00adh9b73\",\n      \"awardNumber\": \"DP2-DK102256\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"National Center for Complementary and Integrative Health Pioneer Award (NCCIH)\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/00190t495\",\n      \"awardNumber\": \"DP1-AT009925\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"Charles A. King Trust Postdoctoral Research Fellowship Program\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"MIT Summer Research Program, supported by the Center for Brains, Minds and Machines (CBMM)\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"National Science Foundation Science and Technology Centers Award\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/021nxhr62\",\n      \"awardNumber\": \"CCF-1231216\",\n      \"includeInCitation\": false\n    },\n    {\n      \"name\": \"Dolby Family Fund\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"includeInCitation\": false\n    }\n  ],\n  \"dateCreated\": \"2024-09-18T17:50:14.994221+00:00\",\n  \"description\": \"Supporting data for the publication \\\"Separable Dorsal Raphe Dopamine Projections Mediate the Facets of Loneliness-like State\\\" by Christopher R. Lee, Gillian A. Matthews, Mackenzie E. Lemieux, Elizabeth M. Wasserlein, Matilde Borio, Raymundo L. Miranda, Laurel R. Keyes, Gates P. Schneider, Caroline Jia, Andrea Tran, Faith Aloboudi, May G. Chan, Enzo Peroni, Grace S. Pereira, Alba L\\u00f3pez-Moraga, Anna Pall\\u00e9, Eyal Y. Kimchi, Nancy Padilla-Coreano, Romy Wichmann, Kay M. Tye.  bioRxiv 2025.02.03.636224; doi: https://doi.org/10.1101/2025.02.03.636224.  \\nThis dataset includes both in vivo calcium imaging data with supporting behavioral videos and ex vivo patch-clamp electrophysiology recordings.\\n\\nEphys Patching data also used in earlier pre-print under the title: \\\"Separable Dorsal Raphe Dopamine Projections Mediate Sociability and Valence\\\" by Gillian A. Matthews, Mackenzie E. Lemieux, Elizabeth M. Brewer, Matilde Borio, Raymundo Miranda, Laurel R. Keyes, Enzo Peroni, Grace S. Pereira, Alba Lopez-Moraga, Anna Pall\\u00e9, Christopher R. Lee, Eyal Y. Kimchi, Nancy Padilla-Coreano, Romy Wichmann, Kay M. Tye.  Research Square. 2021 Dec 3. doi: 10.21203/rs.3.rs-1025403/v1.\",\n  \"publishedBy\": {\n    \"id\": \"urn:uuid:e7b589a6-9018-44fd-8e71-5cba081330b2\",\n    \"name\": \"DANDI publish\",\n    \"endDate\": \"2025-04-08T17:33:12.753743+00:00\",\n    \"schemaKey\": \"PublishActivity\",\n    \"startDate\": \"2025-04-08T17:33:12.753743+00:00\",\n    \"wasAssociatedWith\": [\n      {\n        \"id\": \"urn:uuid:b6817d41-1f9c-4e4a-8e13-227e799e96c4\",\n        \"name\": \"DANDI API\",\n        \"version\": \"0.1.0\",\n        \"schemaKey\": \"Software\",\n        \"identifier\": \"RRID:SCR_017571\"\n      }\n    ]\n  },\n  \"studyTarget\": [\n    \"Affiliative social connections facilitate well-being and survival in numerous species. Engaging in social interactions requires positive or negative motivational drive, elicited through coordinated activity across neural circuits. However, the identity, interconnectivity, and functional encoding of social information within these circuits remains poorly understood. Here, we focus on downstream projections of dorsal raphe nucleus (DRN) dopamine neurons (DRNDAT), which we previously implicated in social motivation alongside an aversive affective state. We show that three prominent DRNDAT projections \\u2013 to the bed nucleus of the stria terminalis (BNST), central amygdala (CeA), and posterior basolateral amygdala (BLP) \\u2013 play separable roles in behavior, despite substantial collateralization. Photoactivation of the DRNDAT-CeA projection promoted social behavior and photostimulation of the DRNDAT-BNST projection promoted exploratory behavior, while the DRNDAT-BLP projection supported place avoidance, suggesting a negative affective state. Downstream regions showed diverse receptor expression, poising DRNDAT neurons to act through dopamine, neuropeptide, and glutamate transmission. Furthermore, we show ex vivo that the effect of DRNDAT photostimulation on downstream neuron excitability depended on region and baseline cell properties, resulting in excitatory responses in BNST cells and diverse responses in CeA and BLP. Finally, in vivo microendoscopic cellular-resolution recordings in the CeA with DRNDAT photostimulation revealed a correlation between social behavior and neurons excited by social stimuli\\u2013 suggesting that increased dopamine tone may recruit different CeA neurons to social ensembles. Collectively, these circuit features may facilitate a coordinated, but flexible, response in the presence of social stimuli that can be flexibly guided based on the internal social homeostatic need state of the individual.\"\n  ],\n  \"assetsSummary\": {\n    \"species\": [\n      {\n        \"name\": \"Mus musculus - House mouse\",\n        \"schemaKey\": \"SpeciesType\",\n        \"identifier\": \"http://purl.obolibrary.org/obo/NCBITaxon_10090\"\n      }\n    ],\n    \"approach\": [\n      {\n        \"name\": \"electrophysiological approach\",\n        \"schemaKey\": \"ApproachType\"\n      },\n      {\n        \"name\": \"microscopy approach; cell population imaging\",\n        \"schemaKey\": \"ApproachType\"\n      }\n    ],\n    \"schemaKey\": \"AssetsSummary\",\n    \"dataStandard\": [\n      {\n        \"name\": \"Neurodata Without Borders (NWB)\",\n        \"schemaKey\": \"StandardsType\",\n        \"identifier\": \"RRID:SCR_015242\"\n      }\n    ],\n    \"numberOfBytes\": 69986574127,\n    \"numberOfCells\": 131,\n    \"numberOfFiles\": 230,\n    \"numberOfSamples\": 8,\n    \"numberOfSubjects\": 34,\n    \"variableMeasured\": [\n      \"CurrentClampStimulusSeries\",\n      \"VoltageClampSeries\",\n      \"VoltageClampStimulusSeries\",\n      \"CurrentClampSeries\",\n      \"OpticalChannel\",\n      \"ImagingPlane\",\n      \"PlaneSegmentation\",\n      \"ProcessingModule\",\n      \"OnePhotonSeries\"\n    ],\n    \"measurementTechnique\": [\n      {\n        \"name\": \"voltage clamp technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      },\n      {\n        \"name\": \"current clamp technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      },\n      {\n        \"name\": \"one-photon microscopy technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      },\n      {\n        \"name\": \"analytical technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      },\n      {\n        \"name\": \"surgical technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      }\n    ]\n  },\n  \"datePublished\": \"2025-04-08T17:33:12.753743+00:00\",\n  \"schemaVersion\": \"0.6.8\",\n  \"ethicsApproval\": [\n    {\n      \"schemaKey\": \"EthicsApproval\",\n      \"identifier\": \"All procedures involving animals were conducted in accordance with NIH guidelines and approved by the MIT Committee on Animal Care or the Salk Institute Institutional Animal Care and Use Committee\",\n      \"contactPoint\": {\n        \"email\": \"rwichmann@salk.edu\",\n        \"schemaKey\": \"ContactPoint\"\n      }\n    }\n  ],\n  \"wasGeneratedBy\": [\n    {\n      \"name\": \"Separable Dorsal Raphe Dopamine Projections Mediate Sociability and Valence\",\n      \"schemaKey\": \"Project\",\n      \"identifier\": \"https://www.researchsquare.com/article/rs-1025403/v1\",\n      \"description\": \"Affiliative social connections facilitate well-being and survival in numerous species. Engaging in social interactions requires positive and negative motivational drive, elicited through coordinated activity across neural circuits. However, the identity, interconnectivity, and functional encoding of social information within these circuits remains poorly understood. Here, we focused on downstream projections of dorsal raphe nucleus (DRN) dopamine neurons (DRNDAT), which we previously implicated in \\u2018negative drive\\u2019-induced social motivation. We show that three prominent DRNDAT projections \\u2013 to the bed nucleus of the stria terminalis (BNST), central amygdala (CeA), and posterior basolateral amygdala (BLP) \\u2013 play separable roles in behavior, despite substantial collateralization. Photoactivation of the DRNDAT-CeA projection promoted social behavior and photoactivation of the DRNDAT-BNST projection promoted exploratory behavior, while the DRNDAT-BLP projection supported place avoidance, suggesting a negative affective state. Downstream regions showed diverse, region-specific, receptor expression, poising DRNDAT neurons to act through dopamine, neuropeptide, and glutamate transmission. Furthermore, we show ex vivo that the effect of DRNDAT photostimulation on downstream neuron excitability was predicted by baseline cell properties, suggesting cell-type-specific modulation. Collectively, these data indicate that DRNDAT neurons may bias behavior via precise modulation of cellular activity in broadly-distributed target structures.\"\n    }\n  ],\n  \"acknowledgement\": \"K.M.T. is the Wylie Vale Chair at the Salk Institute for Biological Studies, a New York Stem Cell Foundation - Robertson Investigator, and a McKnight Scholar. This work was supported by funding from the JPB Foundation, Alfred P Sloan Foundation, New York Stem Cell Foundation, Klingenstein Foundation, McKnight Foundation, Clayton Foundation, Dolby Family Fund, R01-MH115920 (NIMH), the NIH Director\\u2019s New Innovator Award DP2-DK102256 (NIDDK), and Pioneer Award DP1-AT009925 (NCCIH). G.A.M was supported by a Postdoctoral Research Fellowship from the Charles A. King Trust.  R.L.M. was funded through the MSRP program in the Brains & Cognitive Sciences Department at MIT, supported by the Center for Brains, Minds and Machines (CBMM), and funded by NSF STC award CCF\\u0002 1231216. E.M.W was supported by a summer scholarship from Johnson & Johnson. We thank C. Leppla, J. Olsen, P. Namburi, V. Barth, J. Wang, K. Batra, A. Brown, and A. Libster for technical advice, all members of the Tye Lab for helpful discussion, and advice from the CellProfiler team at the Broad Institute. We also thank Rachel Neve for the HSV construct, and Charu Ramakrishnan & Karl Deisseroth for AAV5-fDIO-eYFP. \",\n  \"relatedResource\": [\n    {\n      \"url\": \"https://doi.org/10.7554/eLife.105955.1\",\n      \"name\": \"Separable Dorsal Raphe Dopamine Projections mediate the Facets of Loneliness-like state\",\n      \"relation\": \"dcite:Describes\",\n      \"schemaKey\": \"Resource\",\n      \"identifier\": \"https://doi.org/10.7554/eLife.105955.1\",\n      \"repository\": \"eLife\",\n      \"resourceType\": \"dcite:JournalArticle\"\n    },\n    {\n      \"url\": \"https://doi.org/10.21203/rs.3.rs-1025403/v1\",\n      \"name\": \"Separable Dorsal Raphe Dopamine Projections Mediate Sociability and Valence\",\n      \"relation\": \"dcite:Describes\",\n      \"schemaKey\": \"Resource\",\n      \"identifier\": \"https://doi.org/10.21203/rs.3.rs-1025403/v1\",\n      \"repository\": \"Research Square\",\n      \"resourceType\": \"dcite:Preprint\"\n    }\n  ],\n  \"manifestLocation\": [\n    \"https://dandiarchive.s3.amazonaws.com/dandisets/001195/0.250408.1733/assets.yaml\"\n  ]\n}"
      }
    ]
  },
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is a listing of some of the files in the Dandiset."
      },
      {
        "type": "text",
        "text": "sub-23/sub-23_ses-20150324T134114_slice-slice-1_cell-C1_icephys.nwb\nsub-23/sub-23_ses-20150324T161217_slice-slice-2_cell-B3_icephys.nwb\nsub-235/sub-235_ses-20200921T142415_slice-slice-1_cell-C3_icephys.nwb\nsub-23/sub-23_ses-20150324T154615_slice-slice-2_cell-B2_icephys.nwb\nsub-23/sub-23_ses-20150324T152016_slice-slice-2_cell-B1_icephys.nwb\nsub-235/sub-235_ses-20200921T150553_slice-slice-1_cell-C5_icephys.nwb\nsub-235/sub-235_ses-20200921T131057_slice-slice-1_cell-C1_icephys.nwb\nsub-235/sub-235_ses-20200921T164032_slice-slice-2_cell-C8_icephys.nwb\nsub-235/sub-235_ses-20200921T134852_slice-slice-1_cell-C2_icephys.nwb\nsub-235/sub-235_ses-20200921T172736_slice-slice-2_cell-C10_icephys.nwb"
      }
    ]
  },
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is metadata and usage information about the file sub-23/sub-23_ses-20150324T134114_slice-slice-1_cell-C1_icephys.nwb."
      },
      {
        "type": "text",
        "text": "\nimport pynwb\nimport h5py\nimport remfile\n\n# Load\nfrom dandi.dandiapi import DandiAPIClient\n\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(\"001195\", \"0.250408.1733\")\nurl = next(dandiset.get_assets_by_glob(\"sub-23/sub-23_ses-20150324T134114_slice-slice-1_cell-C1_icephys.nwb\")).download_url\n\nremote_file = remfile.File(url)\nh5_file = h5py.File(remote_file)\nio = pynwb.NWBHDF5IO(file=h5_file)\nnwb = io.read()\n\nnwb # (NWBFile)\nnwb.session_description # (str) episodic stimulation\nnwb.identifier # (str) a18b081c-3b63-45df-b702-fc3640aef3de\nnwb.session_start_time # (datetime) 2015-03-24T13:41:14-07:00\nnwb.timestamps_reference_time # (datetime) 2015-03-24T13:41:14-07:00\nnwb.file_create_date # (list) [datetime.datetime(2025, 4, 3, 16, 56, 47, 408514, tzinfo=tzoffset(None, -25200))]\nnwb.experimenter # (tuple) ['Matthews, Gillian']\nnwb.icephys_electrodes # (LabelledDict)\nicephys_electrodes = nwb.icephys_electrodes\nelectrode_0 = icephys_electrodes[\"electrode-0\"]\nelectrode_0 # (IntracellularElectrode)\nelectrode_0.description # (str) no description\nelectrode_0.device # (Device)\nelectrode_0.device.description # (str) no description\nelectrode_1 = icephys_electrodes[\"electrode-1\"]\nelectrode_1 # (IntracellularElectrode)\nelectrode_1.description # (str) no description\nelectrode_1.device # (Device)\nelectrode_1.device.description # (str) no description\nnwb.acquisition # (LabelledDict)\nacquisition = nwb.acquisition\ncurrent_clamp_response_01_ch_0 = acquisition[\"current_clamp-response-01-ch-0\"]\ncurrent_clamp_response_01_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_01_ch_0.starting_time # (float64) 0.0\ncurrent_clamp_response_01_ch_0.rate # (float64) 10000.0\ncurrent_clamp_response_01_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_01_ch_0.comments # (str) no comments\ncurrent_clamp_response_01_ch_0.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_01_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_01_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_01_ch_0.unit # (str) volts\ncurrent_clamp_response_01_ch_0.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_01_ch_0.data[:] # Access all data\n# current_clamp_response_01_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_01_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_01_ch_0.gain # (float64) nan\ncurrent_clamp_response_01_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_01_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_01_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_01_ch_0.electrode.device # (Device)\ncurrent_clamp_response_01_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_01_ch_1 = acquisition[\"current_clamp-response-01-ch-1\"]\ncurrent_clamp_response_01_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_01_ch_1.starting_time # (float64) 0.0\ncurrent_clamp_response_01_ch_1.rate # (float64) 10000.0\ncurrent_clamp_response_01_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_01_ch_1.comments # (str) no comments\ncurrent_clamp_response_01_ch_1.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_01_ch_1.conversion # (float64) 6.103515335098577e-13\ncurrent_clamp_response_01_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_01_ch_1.unit # (str) volts\ncurrent_clamp_response_01_ch_1.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_01_ch_1.data[:] # Access all data\n# current_clamp_response_01_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_01_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_01_ch_1.gain # (float64) nan\ncurrent_clamp_response_01_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_01_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_01_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_01_ch_1.electrode.device # (Device)\ncurrent_clamp_response_01_ch_1.electrode.device.description # (str) no description\ncurrent_clamp_response_02_ch_0 = acquisition[\"current_clamp-response-02-ch-0\"]\ncurrent_clamp_response_02_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_02_ch_0.starting_time # (float64) 1.0\ncurrent_clamp_response_02_ch_0.rate # (float64) 10000.0\ncurrent_clamp_response_02_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_02_ch_0.comments # (str) no comments\ncurrent_clamp_response_02_ch_0.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_02_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_02_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_02_ch_0.unit # (str) volts\ncurrent_clamp_response_02_ch_0.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_02_ch_0.data[:] # Access all data\n# current_clamp_response_02_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_02_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_02_ch_0.gain # (float64) nan\ncurrent_clamp_response_02_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_02_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_02_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_02_ch_0.electrode.device # (Device)\ncurrent_clamp_response_02_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_02_ch_1 = acquisition[\"current_clamp-response-02-ch-1\"]\ncurrent_clamp_response_02_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_02_ch_1.starting_time # (float64) 1.0\ncurrent_clamp_response_02_ch_1.rate # (float64) 10000.0\ncurrent_clamp_response_02_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_02_ch_1.comments # (str) no comments\ncurrent_clamp_response_02_ch_1.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_02_ch_1.conversion # (float64) 6.103515335098577e-13\ncurrent_clamp_response_02_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_02_ch_1.unit # (str) volts\ncurrent_clamp_response_02_ch_1.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_02_ch_1.data[:] # Access all data\n# current_clamp_response_02_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_02_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_02_ch_1.gain # (float64) nan\ncurrent_clamp_response_02_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_02_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_02_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_02_ch_1.electrode.device # (Device)\ncurrent_clamp_response_02_ch_1.electrode.device.description # (str) no description\ncurrent_clamp_response_03_ch_0 = acquisition[\"current_clamp-response-03-ch-0\"]\ncurrent_clamp_response_03_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_03_ch_0.starting_time # (float64) 2.0\ncurrent_clamp_response_03_ch_0.rate # (float64) 10000.0\ncurrent_clamp_response_03_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_03_ch_0.comments # (str) no comments\ncurrent_clamp_response_03_ch_0.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_03_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_03_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_03_ch_0.unit # (str) volts\ncurrent_clamp_response_03_ch_0.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_03_ch_0.data[:] # Access all data\n# current_clamp_response_03_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_03_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_03_ch_0.gain # (float64) nan\ncurrent_clamp_response_03_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_03_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_03_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_03_ch_0.electrode.device # (Device)\ncurrent_clamp_response_03_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_03_ch_1 = acquisition[\"current_clamp-response-03-ch-1\"]\ncurrent_clamp_response_03_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_03_ch_1.starting_time # (float64) 2.0\ncurrent_clamp_response_03_ch_1.rate # (float64) 10000.0\ncurrent_clamp_response_03_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_03_ch_1.comments # (str) no comments\ncurrent_clamp_response_03_ch_1.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_03_ch_1.conversion # (float64) 6.103515335098577e-13\ncurrent_clamp_response_03_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_03_ch_1.unit # (str) volts\ncurrent_clamp_response_03_ch_1.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_03_ch_1.data[:] # Access all data\n# current_clamp_response_03_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_03_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_03_ch_1.gain # (float64) nan\ncurrent_clamp_response_03_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_03_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_03_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_03_ch_1.electrode.device # (Device)\ncurrent_clamp_response_03_ch_1.electrode.device.description # (str) no description\ncurrent_clamp_response_04_ch_0 = acquisition[\"current_clamp-response-04-ch-0\"]\ncurrent_clamp_response_04_ch_0 # (CurrentClampSeries)\ncurrent_clamp_response_04_ch_0.starting_time # (float64) 3.0\ncurrent_clamp_response_04_ch_0.rate # (float64) 10000.0\ncurrent_clamp_response_04_ch_0.resolution # (float64) -1.0\ncurrent_clamp_response_04_ch_0.comments # (str) no comments\ncurrent_clamp_response_04_ch_0.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_04_ch_0.conversion # (float64) 3.051757880712104e-05\ncurrent_clamp_response_04_ch_0.offset # (float64) 0.0\ncurrent_clamp_response_04_ch_0.unit # (str) volts\ncurrent_clamp_response_04_ch_0.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_04_ch_0.data[:] # Access all data\n# current_clamp_response_04_ch_0.data[0:n] # Access first n elements\ncurrent_clamp_response_04_ch_0.starting_time_unit # (str) seconds\ncurrent_clamp_response_04_ch_0.gain # (float64) nan\ncurrent_clamp_response_04_ch_0.stimulus_description # (str) N/A\ncurrent_clamp_response_04_ch_0.electrode # (IntracellularElectrode)\ncurrent_clamp_response_04_ch_0.electrode.description # (str) no description\ncurrent_clamp_response_04_ch_0.electrode.device # (Device)\ncurrent_clamp_response_04_ch_0.electrode.device.description # (str) no description\ncurrent_clamp_response_04_ch_1 = acquisition[\"current_clamp-response-04-ch-1\"]\ncurrent_clamp_response_04_ch_1 # (CurrentClampSeries)\ncurrent_clamp_response_04_ch_1.starting_time # (float64) 3.0\ncurrent_clamp_response_04_ch_1.rate # (float64) 10000.0\ncurrent_clamp_response_04_ch_1.resolution # (float64) -1.0\ncurrent_clamp_response_04_ch_1.comments # (str) no comments\ncurrent_clamp_response_04_ch_1.description # (str) Response to: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\ncurrent_clamp_response_04_ch_1.conversion # (float64) 6.103515335098577e-13\ncurrent_clamp_response_04_ch_1.offset # (float64) 0.0\ncurrent_clamp_response_04_ch_1.unit # (str) volts\ncurrent_clamp_response_04_ch_1.data # (Dataset) shape (3000,); dtype int16\n# current_clamp_response_04_ch_1.data[:] # Access all data\n# current_clamp_response_04_ch_1.data[0:n] # Access first n elements\ncurrent_clamp_response_04_ch_1.starting_time_unit # (str) seconds\ncurrent_clamp_response_04_ch_1.gain # (float64) nan\ncurrent_clamp_response_04_ch_1.stimulus_description # (str) N/A\ncurrent_clamp_response_04_ch_1.electrode # (IntracellularElectrode)\ncurrent_clamp_response_04_ch_1.electrode.description # (str) no description\ncurrent_clamp_response_04_ch_1.electrode.device # (Device)\ncurrent_clamp_response_04_ch_1.electrode.device.description # (str) no description\n# ...\n# Other fields: current_clamp-response-05-ch-0, current_clamp-response-05-ch-1, current_clamp-response-06-ch-0, current_clamp-response-06-ch-1, current_clamp-response-07-ch-0, current_clamp-response-07-ch-1, current_clamp-response-08-ch-0, current_clamp-response-08-ch-1, current_clamp-response-09-ch-0, current_clamp-response-09-ch-1, current_clamp-response-10-ch-0, current_clamp-response-10-ch-1, current_clamp-response-11-ch-0, current_clamp-response-11-ch-1, current_clamp-response-12-ch-0\n# ... and 64 more fields\nnwb.stimulus # (LabelledDict)\nstimulus = nwb.stimulus\nstimulus_01_ch_0 = stimulus[\"stimulus-01-ch-0\"]\nstimulus_01_ch_0 # (CurrentClampStimulusSeries)\nstimulus_01_ch_0.starting_time # (float64) 0.0\nstimulus_01_ch_0.rate # (float64) 10000.0\nstimulus_01_ch_0.resolution # (float64) -1.0\nstimulus_01_ch_0.comments # (str) no comments\nstimulus_01_ch_0.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_01_ch_0.conversion # (float64) 1e-12\nstimulus_01_ch_0.offset # (float64) 0.0\nstimulus_01_ch_0.unit # (str) amperes\nstimulus_01_ch_0.data # (Dataset) shape (3000,); dtype float64\n# stimulus_01_ch_0.data[:] # Access all data\n# stimulus_01_ch_0.data[0:n] # Access first n elements\nstimulus_01_ch_0.starting_time_unit # (str) seconds\nstimulus_01_ch_0.gain # (float64) nan\nstimulus_01_ch_0.stimulus_description # (str) N/A\nstimulus_01_ch_0.electrode # (IntracellularElectrode)\nstimulus_01_ch_0.electrode.description # (str) no description\nstimulus_01_ch_0.electrode.device # (Device)\nstimulus_01_ch_0.electrode.device.description # (str) no description\nstimulus_01_ch_1 = stimulus[\"stimulus-01-ch-1\"]\nstimulus_01_ch_1 # (CurrentClampStimulusSeries)\nstimulus_01_ch_1.starting_time # (float64) 0.0\nstimulus_01_ch_1.rate # (float64) 10000.0\nstimulus_01_ch_1.resolution # (float64) -1.0\nstimulus_01_ch_1.comments # (str) no comments\nstimulus_01_ch_1.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_01_ch_1.conversion # (float64) 0.001\nstimulus_01_ch_1.offset # (float64) 0.0\nstimulus_01_ch_1.unit # (str) amperes\nstimulus_01_ch_1.data # (Dataset) shape (3000,); dtype float64\n# stimulus_01_ch_1.data[:] # Access all data\n# stimulus_01_ch_1.data[0:n] # Access first n elements\nstimulus_01_ch_1.starting_time_unit # (str) seconds\nstimulus_01_ch_1.gain # (float64) nan\nstimulus_01_ch_1.stimulus_description # (str) N/A\nstimulus_01_ch_1.electrode # (IntracellularElectrode)\nstimulus_01_ch_1.electrode.description # (str) no description\nstimulus_01_ch_1.electrode.device # (Device)\nstimulus_01_ch_1.electrode.device.description # (str) no description\nstimulus_02_ch_0 = stimulus[\"stimulus-02-ch-0\"]\nstimulus_02_ch_0 # (CurrentClampStimulusSeries)\nstimulus_02_ch_0.starting_time # (float64) 1.0\nstimulus_02_ch_0.rate # (float64) 10000.0\nstimulus_02_ch_0.resolution # (float64) -1.0\nstimulus_02_ch_0.comments # (str) no comments\nstimulus_02_ch_0.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_02_ch_0.conversion # (float64) 1e-12\nstimulus_02_ch_0.offset # (float64) 0.0\nstimulus_02_ch_0.unit # (str) amperes\nstimulus_02_ch_0.data # (Dataset) shape (3000,); dtype float64\n# stimulus_02_ch_0.data[:] # Access all data\n# stimulus_02_ch_0.data[0:n] # Access first n elements\nstimulus_02_ch_0.starting_time_unit # (str) seconds\nstimulus_02_ch_0.gain # (float64) nan\nstimulus_02_ch_0.stimulus_description # (str) N/A\nstimulus_02_ch_0.electrode # (IntracellularElectrode)\nstimulus_02_ch_0.electrode.description # (str) no description\nstimulus_02_ch_0.electrode.device # (Device)\nstimulus_02_ch_0.electrode.device.description # (str) no description\nstimulus_02_ch_1 = stimulus[\"stimulus-02-ch-1\"]\nstimulus_02_ch_1 # (CurrentClampStimulusSeries)\nstimulus_02_ch_1.starting_time # (float64) 1.0\nstimulus_02_ch_1.rate # (float64) 10000.0\nstimulus_02_ch_1.resolution # (float64) -1.0\nstimulus_02_ch_1.comments # (str) no comments\nstimulus_02_ch_1.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_02_ch_1.conversion # (float64) 0.001\nstimulus_02_ch_1.offset # (float64) 0.0\nstimulus_02_ch_1.unit # (str) amperes\nstimulus_02_ch_1.data # (Dataset) shape (3000,); dtype float64\n# stimulus_02_ch_1.data[:] # Access all data\n# stimulus_02_ch_1.data[0:n] # Access first n elements\nstimulus_02_ch_1.starting_time_unit # (str) seconds\nstimulus_02_ch_1.gain # (float64) nan\nstimulus_02_ch_1.stimulus_description # (str) N/A\nstimulus_02_ch_1.electrode # (IntracellularElectrode)\nstimulus_02_ch_1.electrode.description # (str) no description\nstimulus_02_ch_1.electrode.device # (Device)\nstimulus_02_ch_1.electrode.device.description # (str) no description\nstimulus_03_ch_0 = stimulus[\"stimulus-03-ch-0\"]\nstimulus_03_ch_0 # (CurrentClampStimulusSeries)\nstimulus_03_ch_0.starting_time # (float64) 2.0\nstimulus_03_ch_0.rate # (float64) 10000.0\nstimulus_03_ch_0.resolution # (float64) -1.0\nstimulus_03_ch_0.comments # (str) no comments\nstimulus_03_ch_0.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_03_ch_0.conversion # (float64) 1e-12\nstimulus_03_ch_0.offset # (float64) 0.0\nstimulus_03_ch_0.unit # (str) amperes\nstimulus_03_ch_0.data # (Dataset) shape (3000,); dtype float64\n# stimulus_03_ch_0.data[:] # Access all data\n# stimulus_03_ch_0.data[0:n] # Access first n elements\nstimulus_03_ch_0.starting_time_unit # (str) seconds\nstimulus_03_ch_0.gain # (float64) nan\nstimulus_03_ch_0.stimulus_description # (str) N/A\nstimulus_03_ch_0.electrode # (IntracellularElectrode)\nstimulus_03_ch_0.electrode.description # (str) no description\nstimulus_03_ch_0.electrode.device # (Device)\nstimulus_03_ch_0.electrode.device.description # (str) no description\nstimulus_03_ch_1 = stimulus[\"stimulus-03-ch-1\"]\nstimulus_03_ch_1 # (CurrentClampStimulusSeries)\nstimulus_03_ch_1.starting_time # (float64) 2.0\nstimulus_03_ch_1.rate # (float64) 10000.0\nstimulus_03_ch_1.resolution # (float64) -1.0\nstimulus_03_ch_1.comments # (str) no comments\nstimulus_03_ch_1.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_03_ch_1.conversion # (float64) 0.001\nstimulus_03_ch_1.offset # (float64) 0.0\nstimulus_03_ch_1.unit # (str) amperes\nstimulus_03_ch_1.data # (Dataset) shape (3000,); dtype float64\n# stimulus_03_ch_1.data[:] # Access all data\n# stimulus_03_ch_1.data[0:n] # Access first n elements\nstimulus_03_ch_1.starting_time_unit # (str) seconds\nstimulus_03_ch_1.gain # (float64) nan\nstimulus_03_ch_1.stimulus_description # (str) N/A\nstimulus_03_ch_1.electrode # (IntracellularElectrode)\nstimulus_03_ch_1.electrode.description # (str) no description\nstimulus_03_ch_1.electrode.device # (Device)\nstimulus_03_ch_1.electrode.device.description # (str) no description\nstimulus_04_ch_0 = stimulus[\"stimulus-04-ch-0\"]\nstimulus_04_ch_0 # (CurrentClampStimulusSeries)\nstimulus_04_ch_0.starting_time # (float64) 3.0\nstimulus_04_ch_0.rate # (float64) 10000.0\nstimulus_04_ch_0.resolution # (float64) -1.0\nstimulus_04_ch_0.comments # (str) no comments\nstimulus_04_ch_0.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_04_ch_0.conversion # (float64) 1e-12\nstimulus_04_ch_0.offset # (float64) 0.0\nstimulus_04_ch_0.unit # (str) amperes\nstimulus_04_ch_0.data # (Dataset) shape (3000,); dtype float64\n# stimulus_04_ch_0.data[:] # Access all data\n# stimulus_04_ch_0.data[0:n] # Access first n elements\nstimulus_04_ch_0.starting_time_unit # (str) seconds\nstimulus_04_ch_0.gain # (float64) nan\nstimulus_04_ch_0.stimulus_description # (str) N/A\nstimulus_04_ch_0.electrode # (IntracellularElectrode)\nstimulus_04_ch_0.electrode.description # (str) no description\nstimulus_04_ch_0.electrode.device # (Device)\nstimulus_04_ch_0.electrode.device.description # (str) no description\nstimulus_04_ch_1 = stimulus[\"stimulus-04-ch-1\"]\nstimulus_04_ch_1 # (CurrentClampStimulusSeries)\nstimulus_04_ch_1.starting_time # (float64) 3.0\nstimulus_04_ch_1.rate # (float64) 10000.0\nstimulus_04_ch_1.resolution # (float64) -1.0\nstimulus_04_ch_1.comments # (str) no comments\nstimulus_04_ch_1.description # (str) Stim type: episodic stimulation, 1s steps, 20pA increments, -120pA to 260pA\nstimulus_04_ch_1.conversion # (float64) 0.001\nstimulus_04_ch_1.offset # (float64) 0.0\nstimulus_04_ch_1.unit # (str) amperes\nstimulus_04_ch_1.data # (Dataset) shape (3000,); dtype float64\n# stimulus_04_ch_1.data[:] # Access all data\n# stimulus_04_ch_1.data[0:n] # Access first n elements\nstimulus_04_ch_1.starting_time_unit # (str) seconds\nstimulus_04_ch_1.gain # (float64) nan\nstimulus_04_ch_1.stimulus_description # (str) N/A\nstimulus_04_ch_1.electrode # (IntracellularElectrode)\nstimulus_04_ch_1.electrode.description # (str) no description\nstimulus_04_ch_1.electrode.device # (Device)\nstimulus_04_ch_1.electrode.device.description # (str) no description\n# ...\n# Other fields: stimulus-05-ch-0, stimulus-05-ch-1, stimulus-06-ch-0, stimulus-06-ch-1, stimulus-07-ch-0, stimulus-07-ch-1, stimulus-08-ch-0, stimulus-08-ch-1, stimulus-09-ch-0, stimulus-09-ch-1, stimulus-10-ch-0, stimulus-10-ch-1, stimulus-11-ch-0, stimulus-11-ch-1, stimulus-12-ch-0\n# ... and 63 more fields\nnwb.devices # (LabelledDict)\ndevices = nwb.devices\nDeviceIcephys = devices[\"DeviceIcephys\"]\nDeviceIcephys # (Device)\nDeviceIcephys.description # (str) no description\nnwb.lab_meta_data # (LabelledDict)\nlab_meta_data = nwb.lab_meta_data\nDandiIcephysMetadata = lab_meta_data[\"DandiIcephysMetadata\"]\nDandiIcephysMetadata # (DandiIcephysMetadata)\nDandiIcephysMetadata.cell_id # (str) C1\nDandiIcephysMetadata.slice_id # (str) slice 1\nDandiIcephysMetadata.targeted_layer # (str) CeA\nDandiIcephysMetadata.inferred_layer # (str) CeA\nnwb.lab # (str) Kay Tye Lab\nnwb.institution # (str) Massachusetts Institute of Technology\nnwb.subject # (Subject)\nnwb.subject.age # (str) P302D\nnwb.subject.age__reference # (str) birth\nnwb.subject.description # (str) AAV5-DIO-ChR2-eYFP into DRN\nnwb.subject.genotype # (str) heterozygote\nnwb.subject.sex # (str) F\nnwb.subject.species # (str) Mus musculus\nnwb.subject.subject_id # (str) 23\nnwb.subject.date_of_birth # (datetime) 2014-05-26T00:00:00-07:00\nnwb.subject.strain # (str) DAT::Cre\nnwb.intracellular_recordings # (IntracellularRecordingsTable)\nnwb.intracellular_recordings.description # (str) A table to group together a stimulus and response from a single electrode and a single simultaneo...\nnwb.intracellular_recordings.colnames # (tuple) []\nnwb.intracellular_recordings.columns # (tuple) []\nnwb.intracellular_recordings.category_tables # (OrderedDict)\nnwb.intracellular_recordings.id # (ElementIdentifiers)\n# nwb.intracellular_recordings.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 86 rows and 0 columns\n# nwb.intracellular_recordings.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.icephys_simultaneous_recordings # (SimultaneousRecordingsTable)\nnwb.icephys_simultaneous_recordings.description # (str) A table for grouping different intracellular recordings from theIntracellularRecordingsTable tabl...\nnwb.icephys_simultaneous_recordings.colnames # (tuple) ['recordings']\nnwb.icephys_simultaneous_recordings.columns # (tuple)\nnwb.icephys_simultaneous_recordings.id # (ElementIdentifiers)\n# nwb.icephys_simultaneous_recordings.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 43 rows and 2 columns\n# nwb.icephys_simultaneous_recordings.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.icephys_simultaneous_recordings.recordings # (VectorIndex) Index for VectorData 'recordings'\n# nwb.icephys_simultaneous_recordings.recordings_index[0] # (DataFrame)\n# nwb.icephys_simultaneous_recordings.recordings_index[1] # (DataFrame)\n# nwb.icephys_simultaneous_recordings.recordings_index[2] # (DataFrame)\n# nwb.icephys_simultaneous_recordings.recordings_index[3] # (DataFrame)\n# ...\nnwb.icephys_sequential_recordings # (SequentialRecordingsTable)\nnwb.icephys_sequential_recordings.description # (str) A table for grouping different intracellular recording simultaneous_recordings from the Simultane...\nnwb.icephys_sequential_recordings.colnames # (tuple) ['simultaneous_recordings', 'stimulus_type']\nnwb.icephys_sequential_recordings.columns # (tuple)\nnwb.icephys_sequential_recordings.id # (ElementIdentifiers)\n# nwb.icephys_sequential_recordings.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 5 rows and 3 columns\n# nwb.icephys_sequential_recordings.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.icephys_sequential_recordings.simultaneous_recordings # (VectorIndex) Index for VectorData 'simultaneous_recordings'\n# nwb.icephys_sequential_recordings.simultaneous_recordings_index[0] # (DataFrame)\n# nwb.icephys_sequential_recordings.simultaneous_recordings_index[1] # (DataFrame)\n# nwb.icephys_sequential_recordings.simultaneous_recordings_index[2] # (DataFrame)\n# nwb.icephys_sequential_recordings.simultaneous_recordings_index[3] # (DataFrame)\n# ...\nnwb.icephys_sequential_recordings.stimulus_type # (VectorData) Column storing the type of stimulus used for the sequential recording"
      }
    ]
  },
  {
    "role": "user",
    "content": "On the basis of the above information, please create a jupytext notebook that introduces dandiset 001195 using the format described below.\n\nThe purpose of the notebook is to help researchers explore the dandiset and get started with a reanalysis.\n\nStart with an appropriate title for the notebook, such as \"Exploring Dandiset 001195: ...\" (that should be a markdown heading).\n\nInform the user that the notebook was generated with the assistance of AI, and that they should be cautious when interpreting the code or results.\n\nProvide an overview of the Dandiset. Include a link to the Dandiset of the form https://dandiarchive.org/dandiset/001195/0.250408.1733.\n\nSummarize what the notebook covers. This should be internally consistent with the notebook you are creating, even if it differs from what is specified in the above information.\n\nList the packages that are required to run the notebook. Assume that these are already installed on the user's system. Do not include any pip install commands in the notebook.\n\nShow how to use the DANDI Python API to information about the dandiset using code similar to the following:\n\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(\"001333\", \"0.250327.2220\")\nmetadata = dandiset.get_raw_metadata()\nprint(f\"Dandiset name: {metadata['name']}\")\nprint(f\"Dandiset URL: {metadata['url']}\")\n\nShow how to use the DANDI Python API to explore the .nwb files in the dandiset.\n\nShow how to load and visualize data from the dandiset based on the above information. Feel free to organize things differently from how they are in the above information, but do not make up new information.\n\nGenerate good quality plots (without being redundant).\n\nLoad NWB data by streaming the remote file (as done in the above information) rather than downloading it.\n\nDo not use any functionality of pynwb or dandi that is not covered in the above information.\n\nYou should stick to material that is covered in the above information and do not hallucinate.\n\nThroughout the notebook, include explanatory markdown cells that guide the user through the process.\n\nThe notebook should be well-documented, and follow best practices Include comments in code cells to explain what each step does.\n\nThe Jupytext should use `# %% [markdown]` for markdown cells and `# %%` delimiters for the code cells.\n\nIf any NWB files have units objects, you should know the following:\nunits.spike_times_index[i] provides the vector of spike times for the i^th unit. It is actually not an index. Do not use units.spike_times.\n\nDo not render or display the nwb object obtained from NWBHDF5IO directly in the notebook as the output could be very large.\n\nUse concise scientific language.\n\nPrioritize correctness and accuracy over verbosity and complexity.\n\nDo not speculate about things that are not supported by the above information.\n\nSTRICT RULE: If a chat conversation is provided above, do not include new analyses that are not covered in that conversation.\n\nSTRICT RULE: If a chat conversation is provided above, you should learn from any feedback in the conversation to avoid pitfalls in plots.\n\nDo not be verbose in your summary or wrap up of the notebook, although you may briefly suggest some general ideas for future exploration.\n\nThere is no need to close files or clean up resources at the end of the notebook.\n\nYour notebook will be evaluated based on the following criteria:\n1. How well did the notebook help you understand the purpose and content of the Dandiset?\n2. After reviewing the notebook, do you feel confident in how to access the different types of data from this Dandiset?\n3. Did the notebook help you understand the structure of the NWB file(s) and how to work with them?\n4. Did the visualizations in the notebook generally help you understand key aspects of the data?\n5. Did any of the visualizations make it harder to understand the data (e.g., due to poor formatting, unclear axes, or misleading displays)?\n6. Do you feel more confident creating your own visualizations of the data after seeing the examples in the notebook?\n7. How well did the visualizations show the structure or complexity of the data?\n8. Were there any interpretations or conclusions in the notebook that felt unclear or not well supported by the data shown?\n9. Did any of the plots or examples feel unnecessarily repetitive or redundant?\n10. Did the notebook help you understand what kinds of questions or analyses you could do next with this Dandiset?\n11. How clear and easy was the notebook to follow?\n12. Did the notebook provide code you could easily reuse or adapt to explore the Dandiset yourself?\n13. Did the notebook help you understand what kinds of questions or analyses you could do next with this Dandiset?\n14. Overall, how helpful was this notebook for getting started with this Dandiset?\n\nYour output must be in the format:\n\n<notebook>\nThe text of the jupytext notebook should appear here.\n</notebook>\n\nNo other text should be included in the response.\n"
  },
  {
    "role": "assistant",
    "content": "<notebook>\n# %% [markdown]\n# # Exploring Dandiset 001195: Separable Dorsal Raphe Dopamine Projections Mediate the Facets of Loneliness-like State\n\n# %% [markdown]\n# > **Note**: This notebook was generated with the assistance of AI. Please be cautious when interpreting the code or results and verify all analyses independently.\n\n# %% [markdown]\n# ## Overview\n\n# %% [markdown]\n# This notebook provides an introduction to [DANDI:001195/0.250408.1733](https://dandiarchive.org/dandiset/001195/0.250408.1733), which contains electrophysiological recordings and calcium imaging data supporting the research on dorsal raphe nucleus (DRN) dopamine neurons and their projections to various brain regions.\n# \n# The dataset examines how DRN dopamine projections to three distinct brain regions - bed nucleus of the stria terminalis (BNST), central amygdala (CeA), and posterior basolateral amygdala (BLP) - mediate different aspects of social behavior and affective states.\n\n# %% [markdown]\n# In this notebook, we will:\n# \n# 1. Explore the Dandiset metadata\n# 2. Browse the available NWB files \n# 3. Examine the structure of intracellular electrophysiology recordings\n# 4. Visualize current-clamp response data\n# 5. Compare stimulus and response relationships\n\n# %% [markdown]\n# ## Required Packages\n\n# %%\nimport pynwb\nimport h5py\nimport remfile\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom dandi.dandiapi import DandiAPIClient\nimport pandas as pd\nfrom datetime import datetime\n\n# %% [markdown]\n# ## Exploring Dandiset Metadata\n\n# %%\n# Initialize DANDI client and get metadata\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(\"001195\", \"0.250408.1733\")\nmetadata = dandiset.get_raw_metadata()\n\nprint(f\"Dandiset name: {metadata['name']}\")\nprint(f\"Dandiset URL: {metadata['url']}\")\nprint(f\"DOI: {metadata['doi']}\")\nprint(f\"Version: {metadata['version']}\")\n\n# %% [markdown]\n# Let's look at key metadata fields that describe the research focus:\n\n# %%\n# Display subject information\nprint(\"About:\")\nfor item in metadata.get('about', []):\n    print(f\"- {item.get('name', 'N/A')}\")\n\nprint(\"\\nKeywords:\")\nfor keyword in metadata.get('keywords', []):\n    print(f\"- {keyword}\")\n\nprint(\"\\nStudy Target Summary:\")\nfor target in metadata.get('studyTarget', []):\n    # Truncate long descriptions for display\n    description = target[:200] + \"...\" if len(target) > 200 else target\n    print(f\"- {description}\")\n\n# %% [markdown]\n# ## Exploring NWB Files in the Dandiset\n\n# %%\n# Get a list of all assets\nassets = list(dandiset.get_assets())\nprint(f\"Total number of assets: {len(assets)}\")\n\n# Filter for NWB files\nnwb_files = [asset for asset in assets if asset.path.endswith('.nwb')]\nprint(f\"Number of NWB files: {len(nwb_files)}\")\n\n# Display the first 10 NWB files\nprint(\"\\nSample of NWB files:\")\nfor i, nwb_file in enumerate(nwb_files[:10]):\n    print(f\"{i+1}. {nwb_file.path}\")\n\n# %% [markdown]\n# Let's categorize the files based on their naming patterns to understand the data organization:\n\n# %%\n# Extract information from filenames\nfile_info = []\nfor asset in nwb_files:\n    parts = asset.path.split('/')\n    filename = parts[-1]\n    components = filename.split('_')\n    \n    subject_id = components[0] if len(components) > 0 else 'unknown'\n    session_id = components[1] if len(components) > 1 else 'unknown'\n    remaining = '_'.join(components[2:]) if len(components) > 2 else 'unknown'\n    \n    file_info.append({\n        'path': asset.path,\n        'subject_id': subject_id,\n        'session_id': session_id,\n        'details': remaining,\n        'size_bytes': asset.size\n    })\n\n# Convert to DataFrame for analysis\ndf_files = pd.DataFrame(file_info)\n\n# Show distribution by subject\nsubject_counts = df_files['subject_id'].value_counts()\nprint(\"Number of files per subject:\")\nprint(subject_counts.head(10))\n\n# %% [markdown]\n# ## Loading and Examining an Intracellular Electrophysiology Recording\n\n# %% [markdown]\n# Let's load one of the NWB files to explore its structure. We'll examine the intracellular electrophysiology recording (icephys) data.\n\n# %%\n# Select an NWB file to examine\nfile_to_examine = \"sub-23/sub-23_ses-20150324T134114_slice-slice-1_cell-C1_icephys.nwb\"\n\n# Find the asset by path\nasset = next(dandiset.get_assets_by_glob(file_to_examine))\nurl = asset.download_url\n\n# Use remfile to stream the data rather than downloading it\nremote_file = remfile.File(url)\nh5_file = h5py.File(remote_file)\nio = pynwb.NWBHDF5IO(file=h5_file)\nnwb = io.read()\n\n# %% [markdown]\n# Let's examine the basic data structure and metadata of this NWB file:\n\n# %%\n# Print basic information about the file\nprint(f\"Session ID: {nwb.identifier}\")\nprint(f\"Session Description: {nwb.session_description}\")\nprint(f\"Session Start Time: {nwb.session_start_time}\")\nprint(f\"Experimenter: {nwb.experimenter}\")\nprint(f\"Lab: {nwb.lab}\")\nprint(f\"Institution: {nwb.institution}\")\n\n# Subject information\nsubject = nwb.subject\nprint(\"\\nSubject Information:\")\nprint(f\"Subject ID: {subject.subject_id}\")\nprint(f\"Age: {subject.age}\")\nprint(f\"Sex: {subject.sex}\")\nprint(f\"Species: {subject.species}\")\nprint(f\"Genotype: {subject.genotype}\")\nprint(f\"Strain: {subject.strain}\")\nprint(f\"Description: {subject.description}\")\n\n# %% [markdown]\n# ### Exploring the Intracellular Electrophysiology Data Structure\n\n# %%\n# Get information about the electrodes used in the recording\nprint(\"Intracellular Electrodes:\")\nfor electrode_id, electrode in nwb.icephys_electrodes.items():\n    print(f\"  {electrode_id}:\")\n    print(f\"    Description: {electrode.description}\")\n    print(f\"    Device: {electrode.device.name}\")\n\n# Examine the DANDI-specific metadata\nif hasattr(nwb, 'lab_meta_data') and 'DandiIcephysMetadata' in nwb.lab_meta_data:\n    dandi_meta = nwb.lab_meta_data['DandiIcephysMetadata']\n    print(\"\\nDANDI Icephys Metadata:\")\n    print(f\"  Cell ID: {dandi_meta.cell_id}\")\n    print(f\"  Slice ID: {dandi_meta.slice_id}\")\n    print(f\"  Targeted Layer: {dandi_meta.targeted_layer}\")\n    print(f\"  Inferred Layer: {dandi_meta.inferred_layer}\")\n\n# %% [markdown]\n# Let's look at the structure of the acquisition (response) data:\n\n# %%\n# List the acquisition (response) data series\nprint(\"Acquisition (Response) Data Series:\")\nfor i, (series_name, series) in enumerate(nwb.acquisition.items()):\n    if i >= 5:  # Limit to first 5 for brevity\n        print(f\"  ... and {len(nwb.acquisition) - 5} more series\")\n        break\n    print(f\"  {series_name}:\")\n    print(f\"    Type: {type(series).__name__}\")\n    print(f\"    Description: {series.description[:100]}...\" if len(series.description) > 100 else f\"    Description: {series.description}\")\n    print(f\"    Rate: {series.rate} Hz\")\n    print(f\"    Unit: {series.unit}\")\n\n# %% [markdown]\n# And let's examine the stimulus data:\n\n# %%\n# List the stimulus data series\nprint(\"Stimulus Data Series:\")\nfor i, (series_name, series) in enumerate(nwb.stimulus.items()):\n    if i >= 5:  # Limit to first 5 for brevity\n        print(f\"  ... and {len(nwb.stimulus) - 5} more series\")\n        break\n    print(f\"  {series_name}:\")\n    print(f\"    Type: {type(series).__name__}\")\n    print(f\"    Description: {series.description[:100]}...\" if len(series.description) > 100 else f\"    Description: {series.description}\")\n    print(f\"    Rate: {series.rate} Hz\")\n    print(f\"    Unit: {series.unit}\")\n\n# %% [markdown]\n# Let's look at the relationship between stimulus and recordings using the icephys tables:\n\n# %%\n# Look at the structure of intracellular recordings tables\nprint(\"Intracellular Recordings Table:\")\ntry:\n    icr_df = nwb.intracellular_recordings.to_dataframe()\n    print(f\"  Number of recordings: {len(icr_df)}\")\nexcept:\n    print(\"  Could not convert to dataframe\")\n\nprint(\"\\nSimultaneous Recordings Table:\")\ntry:\n    sim_df = nwb.icephys_simultaneous_recordings.to_dataframe()\n    print(f\"  Number of simultaneous recording groups: {len(sim_df)}\")\n    print(f\"  Columns: {sim_df.columns.tolist()}\")\nexcept:\n    print(\"  Could not convert to dataframe\")\n\nprint(\"\\nSequential Recordings Table:\")\ntry:\n    seq_df = nwb.icephys_sequential_recordings.to_dataframe()\n    print(f\"  Number of sequential recording groups: {len(seq_df)}\")\n    print(f\"  Columns: {seq_df.columns.tolist()}\")\nexcept:\n    print(\"  Could not convert to dataframe\")\n\n# %% [markdown]\n# ## Visualizing the Electrophysiology Data\n\n# %% [markdown]\n# Now let's visualize the current clamp responses to different stimulus intensities. We'll plot response traces for several stimulus conditions.\n\n# %%\n# Function to extract and plot traces\ndef plot_stimulus_and_response(stimulus_name, response_name, title=None):\n    stimulus = nwb.stimulus[stimulus_name]\n    response = nwb.acquisition[response_name]\n    \n    # Create time array based on sampling rate\n    dt = 1.0 / stimulus.rate\n    time = np.arange(0, len(stimulus.data) * dt, dt)\n    \n    # Create figure with two panels\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n    \n    # Plot stimulus\n    ax1.plot(time, stimulus.data, 'b-')\n    ax1.set_ylabel(f'Stimulus ({stimulus.unit})')\n    ax1.set_title(f'{title if title else stimulus_name} - Stimulus')\n    ax1.grid(True)\n    \n    # Plot response\n    response_data = response.data[:] * response.conversion  # Apply conversion factor\n    ax2.plot(time, response_data, 'r-')\n    ax2.set_xlabel('Time (s)')\n    ax2.set_ylabel(f'Response ({response.unit})')\n    ax2.set_title(f'{title if title else response_name} - Response')\n    ax2.grid(True)\n    \n    plt.tight_layout()\n    return fig\n\n# Plot the stimulus and response for a few episodes\nfor i in range(1, 5):  # Plot first 4 episodes\n    stim_name = f\"stimulus-{i:02d}-ch-0\"\n    resp_name = f\"current_clamp-response-{i:02d}-ch-0\"\n    \n    if stim_name in nwb.stimulus and resp_name in nwb.acquisition:\n        current_value = (i-1) * 20 - 120  # Calculate current value (-120pA + 20pA increments)\n        plot_stimulus_and_response(stim_name, resp_name, f\"Episode {i}: {current_value}pA\")\n    else:\n        print(f\"Could not find {stim_name} or {resp_name}\")\n\n# %% [markdown]\n# Let's create a summary plot showing multiple response traces to compare the cell's response to different stimulus intensities:\n\n# %%\n# Function to extract a specific current clamp trace\ndef get_trace(episode_num, channel=0):\n    resp_name = f\"current_clamp-response-{episode_num:02d}-ch-{channel}\"\n    stim_name = f\"stimulus-{episode_num:02d}-ch-{channel}\"\n    \n    if resp_name in nwb.acquisition and stim_name in nwb.stimulus:\n        response = nwb.acquisition[resp_name]\n        stimulus = nwb.stimulus[stim_name]\n        \n        # Calculate time array\n        dt = 1.0 / response.rate\n        time = np.arange(0, len(response.data) * dt, dt)\n        \n        # Convert response to volts using conversion factor\n        response_data = response.data[:] * response.conversion\n        \n        # Calculate stimulus amplitude (take median of non-zero values)\n        stim_data = stimulus.data[:]\n        non_zero = stim_data[abs(stim_data) > 1e-10]\n        stim_amplitude = 0\n        if len(non_zero) > 0:\n            stim_amplitude = np.median(non_zero) * 1e12  # Convert to pA\n        \n        return time, response_data, stim_amplitude\n    else:\n        return None, None, None\n\n# Plot multiple traces to compare responses\nplt.figure(figsize=(12, 8))\n\n# Choose a range of episodes to plot\nepisodes_to_plot = [1, 5, 9, 13, 17, 21]  # Different stimulus levels\ncolors = plt.cm.viridis(np.linspace(0, 1, len(episodes_to_plot)))\n\nfor i, episode in enumerate(episodes_to_plot):\n    time, response, stim_amp = get_trace(episode)\n    \n    if time is not None and response is not None:\n        plt.plot(time, response, color=colors[i], lw=1.5, \n                 label=f\"Episode {episode}: {stim_amp:.0f} pA\")\n\nplt.xlabel('Time (seconds)')\nplt.ylabel('Membrane Potential (V)')\nplt.title('Comparison of Current Clamp Responses Across Different Stimulus Intensities')\nplt.legend(loc='upper right')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# ### Analyzing Response Properties\n\n# %% [markdown]\n# Now let's analyze the response properties across different stimulus intensities to better understand the cell's electrophysiological characteristics.\n\n# %%\n# Analyze response properties across different stimulus intensities\ndef analyze_response_properties(max_episodes=20):\n    # Initialize lists to store results\n    stim_values = []\n    peak_responses = []\n    steady_state_responses = []\n    \n    for episode in range(1, max_episodes+1):\n        time, response, stim_amp = get_trace(episode)\n        \n        if time is not None and response is not None and len(response) > 0:\n            # Find the stimulus onset and offset times (assuming 0.4s delay and 1s duration)\n            onset_idx = int(0.4 * len(time))\n            offset_idx = int(1.4 * len(time))\n            \n            if onset_idx < len(response) and offset_idx < len(response):\n                # Get baseline before stimulus\n                baseline = np.mean(response[int(0.1*len(time)):onset_idx])\n                \n                # Calculate peak response (max deviation from baseline)\n                peak_segment = response[onset_idx:offset_idx]\n                if stim_amp > 0:  # Depolarizing stimulus\n                    peak = np.max(peak_segment) - baseline\n                else:  # Hyperpolarizing stimulus\n                    peak = baseline - np.min(peak_segment)\n                \n                # Calculate steady-state response (average of last 100ms of stimulus)\n                steady_idx_start = offset_idx - int(0.1 * len(time))\n                steady_state = np.mean(response[steady_idx_start:offset_idx]) - baseline\n                \n                # Store results\n                stim_values.append(stim_amp)\n                peak_responses.append(peak)\n                steady_state_responses.append(steady_state)\n    \n    return stim_values, peak_responses, steady_state_responses\n\n# Perform analysis\nstim_values, peak_responses, steady_state_responses = analyze_response_properties(max_episodes=25)\n\n# Plot results\nplt.figure(figsize=(10, 6))\nplt.plot(stim_values, peak_responses, 'o-', label='Peak Response')\nplt.plot(stim_values, steady_state_responses, 's-', label='Steady-State Response')\nplt.axhline(y=0, color='k', linestyle='--', alpha=0.3)\nplt.axvline(x=0, color='k', linestyle='--', alpha=0.3)\nplt.xlabel('Stimulus Amplitude (pA)')\nplt.ylabel('Voltage Response (V)')\nplt.title('Current-Voltage Relationship')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# Let's create a spike raster plot to visualize the cell's firing pattern in response to different stimulus intensities:\n\n# %%\n# Function to detect action potentials\ndef detect_spikes(response, threshold=0.01, min_spike_interval=0.001, time=None):\n    \"\"\"Detect spikes in a voltage trace using a simple threshold crossing method\"\"\"\n    if time is None:\n        time = np.arange(len(response))\n    \n    # Compute derivative to find rapid voltage changes\n    dv_dt = np.diff(response)\n    \n    # Find threshold crossings with high dv/dt\n    crossings = np.where((dv_dt > threshold) & (response[:-1] > -0.04))[0]\n    \n    # Filter out multiple crossings for the same spike\n    if len(crossings) > 0:\n        spike_times = [time[crossings[0]]]\n        for i in range(1, len(crossings)):\n            if time[crossings[i]] - spike_times[-1] > min_spike_interval:\n                spike_times.append(time[crossings[i]])\n        return spike_times\n    return []\n\n# Create a raster plot of spikes across different current steps\nplt.figure(figsize=(12, 8))\n\n# Track whether any spikes were found\nspikes_found = False\n\n# Process a range of episodes\nfor episode in range(1, 25):  # First 25 episodes\n    time, response, stim_amp = get_trace(episode)\n    \n    if time is not None and response is not None and len(response) > 0:\n        # Detect spikes\n        spike_times = detect_spikes(response, threshold=0.015, min_spike_interval=0.001, time=time)\n        \n        if len(spike_times) > 0:\n            spikes_found = True\n            plt.plot(spike_times, [episode] * len(spike_times), 'k|', markersize=15)\n        \n        # Annotate with stimulus amplitude\n        plt.text(time[-1] + 0.05, episode, f\"{stim_amp:.0f} pA\", va='center')\n\n# Add stimulus period indication\nif time is not None:  # Use time from the last processed trace\n    plt.axvspan(0.4, 1.4, alpha=0.2, color='gray', label='Stimulus Period')\n\nplt.xlabel('Time (seconds)')\nplt.ylabel('Episode Number')\nplt.title('Spike Raster Plot Across Different Current Steps')\nplt.ylim(0.5, 25.5)\nplt.xlim(-0.1, time[-1] + 0.3 if time is not None else 3.0)\nplt.grid(True, alpha=0.3, axis='y')\n\nif not spikes_found:\n    plt.text(1.5, 12.5, \"No spikes detected\", fontsize=14, ha='center')\n    \nplt.legend()\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# ## Summary\n\n# %% [markdown]\n# In this notebook, we explored Dandiset 001195, which contains electrophysiological recordings from dorsal raphe nucleus (DRN) dopamine neurons and their projections to various brain regions. We:\n# \n# 1. Examined the metadata to understand the scientific context of the dataset\n# 2. Explored the structure of the NWB files within the dandiset\n# 3. Analyzed intracellular electrophysiology data, focusing on current-clamp recordings\n# 4. Visualized responses to different stimulus intensities\n# 5. Created analysis plots showing current-voltage relationships and spiking patterns\n# \n# Future explorations could include:\n# - Comparing recordings across different brain regions (BNST, CeA, BLP)\n# - Analyzing calcium imaging data included in the dataset\n# - Examining response differences between experimental conditions\n# - Correlating electrophysiological properties with behavioral outcomes\n</notebook>"
  },
  {
    "role": "user",
    "content": "The notebook execution failed with the following error:\n\nNotebook execution failed: [NbClientApp] Executing notebooks/dandisets/001195/0.250408.1733/skip-explore/claude-3.7-sonnet/h-4/notebook.ipynb\n[NbClientApp] Executing notebook with kernel: \nTraceback (most recent call last):\n  File \"/opt/conda/bin/jupyter-execute\", line 10, in <module>\n    sys.exit(main())\n             ^^^^^^\n  File \"/opt/conda/lib/python3.11/site-packages/jupyter_core/application.py\", line 283, in launch_instance\n    super().launch_instance(argv=argv, **kwargs)\n  File \"/opt/conda/lib/python3.11/site-packages/traitlets/config/application.py\", line 1074, in launch_instance\n    app.initialize(argv)\n  File \"/opt/conda/lib/python3.11/site-packages/traitlets/config/application.py\", line 118, in inner\n    return method(app, *args, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/conda/lib/python3.11/site-packages/nbclient/cli.py\", line 161, in initialize\n    self.run_notebook(path)\n  File \"/opt/conda/lib/python3.11/site-packages/nbclient/cli.py\", line 215, in run_notebook\n    client.execute()\n  File \"/opt/conda/lib/python3.11/site-packages/jupyter_core/utils/__init__.py\", line 165, in wrapped\n    return loop.run_until_complete(inner)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/opt/conda/lib/python3.11/asyncio/base_events.py\", line 654, in run_until_complete\n    return future.result()\n           ^^^^^^^^^^^^^^^\n  File \"/opt/conda/lib/python3.11/site-packages/nbclient/client.py\", line 709, in async_execute\n    await self.async_execute_cell(\n  File \"/opt/conda/lib/python3.11/site-packages/nbclient/client.py\", line 1062, in async_execute_cell\n    await self._check_raise_for_error(cell, cell_index, exec_reply)\n  File \"/opt/conda/lib/python3.11/site-packages/nbclient/client.py\", line 918, in _check_raise_for_error\n    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)\nnbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:\n------------------\n# Function to extract and plot traces\ndef plot_stimulus_and_response(stimulus_name, response_name, title=None):\n    stimulus = nwb.stimulus[stimulus_name]\n    response = nwb.acquisition[response_name]\n    \n    # Create time array based on sampling rate\n    dt = 1.0 / stimulus.rate\n    time = np.arange(0, len(stimulus.data) * dt, dt)\n    \n    # Create figure with two panels\n    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 8), sharex=True)\n    \n    # Plot stimulus\n    ax1.plot(time, stimulus.data, 'b-')\n    ax1.set_ylabel(f'Stimulus ({stimulus.unit})')\n    ax1.set_title(f'{title if title else stimulus_name} - Stimulus')\n    ax1.grid(True)\n    \n    # Plot response\n    response_data = response.data[:] * response.conversion  # Apply conversion factor\n    ax2.plot(time, response_data, 'r-')\n    ax2.set_xlabel('Time (s)')\n    ax2.set_ylabel(f'Response ({response.unit})')\n    ax2.set_title(f'{title if title else response_name} - Response')\n    ax2.grid(True)\n    \n    plt.tight_layout()\n    return fig\n\n# Plot the stimulus and response for a few episodes\nfor i in range(1, 5):  # Plot first 4 episodes\n    stim_name = f\"stimulus-{i:02d}-ch-0\"\n    resp_name = f\"current_clamp-response-{i:02d}-ch-0\"\n    \n    if stim_name in nwb.stimulus and resp_name in nwb.acquisition:\n        current_value = (i-1) * 20 - 120  # Calculate current value (-120pA + 20pA increments)\n        plot_stimulus_and_response(stim_name, resp_name, f\"Episode {i}: {current_value}pA\")\n    else:\n        print(f\"Could not find {stim_name} or {resp_name}\")\n------------------\n\n\n\u001b[0;31m---------------------------------------------------------------------------\u001b[0m\n\u001b[0;31mValueError\u001b[0m                                Traceback (most recent call last)\nCell \u001b[0;32mIn[12], line 37\u001b[0m\n\u001b[1;32m     35\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m stim_name \u001b[38;5;129;01min\u001b[39;00m nwb\u001b[38;5;241m.\u001b[39mstimulus \u001b[38;5;129;01mand\u001b[39;00m resp_name \u001b[38;5;129;01min\u001b[39;00m nwb\u001b[38;5;241m.\u001b[39macquisition:\n\u001b[1;32m     36\u001b[0m     current_value \u001b[38;5;241m=\u001b[39m (i\u001b[38;5;241m-\u001b[39m\u001b[38;5;241m1\u001b[39m) \u001b[38;5;241m*\u001b[39m \u001b[38;5;241m20\u001b[39m \u001b[38;5;241m-\u001b[39m \u001b[38;5;241m120\u001b[39m  \u001b[38;5;66;03m# Calculate current value (-120pA + 20pA increments)\u001b[39;00m\n\u001b[0;32m---> 37\u001b[0m     \u001b[43mplot_stimulus_and_response\u001b[49m\u001b[43m(\u001b[49m\u001b[43mstim_name\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mresp_name\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43mf\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43mEpisode \u001b[39;49m\u001b[38;5;132;43;01m{\u001b[39;49;00m\u001b[43mi\u001b[49m\u001b[38;5;132;43;01m}\u001b[39;49;00m\u001b[38;5;124;43m: \u001b[39;49m\u001b[38;5;132;43;01m{\u001b[39;49;00m\u001b[43mcurrent_value\u001b[49m\u001b[38;5;132;43;01m}\u001b[39;49;00m\u001b[38;5;124;43mpA\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m     38\u001b[0m \u001b[38;5;28;01melse\u001b[39;00m:\n\u001b[1;32m     39\u001b[0m     \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mCould not find \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mstim_name\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m or \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mresp_name\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n\nCell \u001b[0;32mIn[12], line 14\u001b[0m, in \u001b[0;36mplot_stimulus_and_response\u001b[0;34m(stimulus_name, response_name, title)\u001b[0m\n\u001b[1;32m     11\u001b[0m fig, (ax1, ax2) \u001b[38;5;241m=\u001b[39m plt\u001b[38;5;241m.\u001b[39msubplots(\u001b[38;5;241m2\u001b[39m, \u001b[38;5;241m1\u001b[39m, figsize\u001b[38;5;241m=\u001b[39m(\u001b[38;5;241m10\u001b[39m, \u001b[38;5;241m8\u001b[39m), sharex\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n\u001b[1;32m     13\u001b[0m \u001b[38;5;66;03m# Plot stimulus\u001b[39;00m\n\u001b[0;32m---> 14\u001b[0m \u001b[43max1\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mplot\u001b[49m\u001b[43m(\u001b[49m\u001b[43mtime\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mstimulus\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mdata\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[38;5;124;43mb-\u001b[39;49m\u001b[38;5;124;43m'\u001b[39;49m\u001b[43m)\u001b[49m\n\u001b[1;32m     15\u001b[0m ax1\u001b[38;5;241m.\u001b[39mset_ylabel(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mStimulus (\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mstimulus\u001b[38;5;241m.\u001b[39munit\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m)\u001b[39m\u001b[38;5;124m'\u001b[39m)\n\u001b[1;32m     16\u001b[0m ax1\u001b[38;5;241m.\u001b[39mset_title(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m'\u001b[39m\u001b[38;5;132;01m{\u001b[39;00mtitle\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mif\u001b[39;00m\u001b[38;5;250m \u001b[39mtitle\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01melse\u001b[39;00m\u001b[38;5;250m \u001b[39mstimulus_name\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m - Stimulus\u001b[39m\u001b[38;5;124m'\u001b[39m)\n\nFile \u001b[0;32m/opt/conda/lib/python3.11/site-packages/matplotlib/axes/_axes.py:1779\u001b[0m, in \u001b[0;36mAxes.plot\u001b[0;34m(self, scalex, scaley, data, *args, **kwargs)\u001b[0m\n\u001b[1;32m   1536\u001b[0m \u001b[38;5;250m\u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[1;32m   1537\u001b[0m \u001b[38;5;124;03mPlot y versus x as lines and/or markers.\u001b[39;00m\n\u001b[1;32m   1538\u001b[0m \n\u001b[0;32m   (...)\u001b[0m\n\u001b[1;32m   1776\u001b[0m \u001b[38;5;124;03m(``'green'``) or hex strings (``'#008000'``).\u001b[39;00m\n\u001b[1;32m   1777\u001b[0m \u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[1;32m   1778\u001b[0m kwargs \u001b[38;5;241m=\u001b[39m cbook\u001b[38;5;241m.\u001b[39mnormalize_kwargs(kwargs, mlines\u001b[38;5;241m.\u001b[39mLine2D)\n\u001b[0;32m-> 1779\u001b[0m lines \u001b[38;5;241m=\u001b[39m [\u001b[38;5;241m*\u001b[39m\u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_get_lines(\u001b[38;5;28mself\u001b[39m, \u001b[38;5;241m*\u001b[39margs, data\u001b[38;5;241m=\u001b[39mdata, \u001b[38;5;241m*\u001b[39m\u001b[38;5;241m*\u001b[39mkwargs)]\n\u001b[1;32m   1780\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m line \u001b[38;5;129;01min\u001b[39;00m lines:\n\u001b[1;32m   1781\u001b[0m     \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39madd_line(line)\n\nFile \u001b[0;32m/opt/conda/lib/python3.11/site-packages/matplotlib/axes/_base.py:296\u001b[0m, in \u001b[0;36m_process_plot_var_args.__call__\u001b[0;34m(self, axes, data, *args, **kwargs)\u001b[0m\n\u001b[1;32m    294\u001b[0m     this \u001b[38;5;241m+\u001b[39m\u001b[38;5;241m=\u001b[39m args[\u001b[38;5;241m0\u001b[39m],\n\u001b[1;32m    295\u001b[0m     args \u001b[38;5;241m=\u001b[39m args[\u001b[38;5;241m1\u001b[39m:]\n\u001b[0;32m--> 296\u001b[0m \u001b[38;5;28;01myield from\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_plot_args\u001b[49m\u001b[43m(\u001b[49m\n\u001b[1;32m    297\u001b[0m \u001b[43m    \u001b[49m\u001b[43maxes\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mthis\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mkwargs\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mambiguous_fmt_datakey\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mambiguous_fmt_datakey\u001b[49m\u001b[43m)\u001b[49m\n\nFile \u001b[0;32m/opt/conda/lib/python3.11/site-packages/matplotlib/axes/_base.py:494\u001b[0m, in \u001b[0;36m_process_plot_var_args._plot_args\u001b[0;34m(self, axes, tup, kwargs, return_kwargs, ambiguous_fmt_datakey)\u001b[0m\n\u001b[1;32m    492\u001b[0m     x \u001b[38;5;241m=\u001b[39m x[:, np\u001b[38;5;241m.\u001b[39mnewaxis]\n\u001b[1;32m    493\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m y\u001b[38;5;241m.\u001b[39mndim \u001b[38;5;241m==\u001b[39m \u001b[38;5;241m1\u001b[39m:\n\u001b[0;32m--> 494\u001b[0m     y \u001b[38;5;241m=\u001b[39m \u001b[43my\u001b[49m\u001b[43m[\u001b[49m\u001b[43m:\u001b[49m\u001b[43m,\u001b[49m\u001b[43m \u001b[49m\u001b[43mnp\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mnewaxis\u001b[49m\u001b[43m]\u001b[49m\n\u001b[1;32m    496\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39mcommand \u001b[38;5;241m==\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mplot\u001b[39m\u001b[38;5;124m'\u001b[39m:\n\u001b[1;32m    497\u001b[0m     make_artist \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_makeline\n\nFile \u001b[0;32mh5py/_objects.pyx:54\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n\nFile \u001b[0;32mh5py/_objects.pyx:55\u001b[0m, in \u001b[0;36mh5py._objects.with_phil.wrapper\u001b[0;34m()\u001b[0m\n\nFile \u001b[0;32m/opt/conda/lib/python3.11/site-packages/h5py/_hl/dataset.py:781\u001b[0m, in \u001b[0;36mDataset.__getitem__\u001b[0;34m(self, args, new_dtype)\u001b[0m\n\u001b[1;32m    779\u001b[0m \u001b[38;5;28;01mif\u001b[39;00m \u001b[38;5;28mself\u001b[39m\u001b[38;5;241m.\u001b[39m_fast_read_ok \u001b[38;5;129;01mand\u001b[39;00m (new_dtype \u001b[38;5;129;01mis\u001b[39;00m \u001b[38;5;28;01mNone\u001b[39;00m):\n\u001b[1;32m    780\u001b[0m     \u001b[38;5;28;01mtry\u001b[39;00m:\n\u001b[0;32m--> 781\u001b[0m         \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28;43mself\u001b[39;49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43m_fast_reader\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mread\u001b[49m\u001b[43m(\u001b[49m\u001b[43margs\u001b[49m\u001b[43m)\u001b[49m\n\u001b[1;32m    782\u001b[0m     \u001b[38;5;28;01mexcept\u001b[39;00m \u001b[38;5;167;01mTypeError\u001b[39;00m:\n\u001b[1;32m    783\u001b[0m         \u001b[38;5;28;01mpass\u001b[39;00m  \u001b[38;5;66;03m# Fall back to Python read pathway below\u001b[39;00m\n\nFile \u001b[0;32mh5py/_selector.pyx:361\u001b[0m, in \u001b[0;36mh5py._selector.Reader.read\u001b[0;34m()\u001b[0m\n\nFile \u001b[0;32mh5py/_selector.pyx:107\u001b[0m, in \u001b[0;36mh5py._selector.Selector.apply_args\u001b[0;34m()\u001b[0m\n\n\u001b[0;31mValueError\u001b[0m: 2 indexing arguments for 1 dimensions\n\n\n\nPlease provide a corrected version of the notebook."
  },
  {
    "role": "assistant",
    "content": "<notebook>\n# %% [markdown]\n# # Exploring Dandiset 001195: Separable Dorsal Raphe Dopamine Projections Mediate the Facets of Loneliness-like State\n\n# %% [markdown]\n# > **Note**: This notebook was generated with the assistance of AI. Please be cautious when interpreting the code or results and verify all analyses independently.\n\n# %% [markdown]\n# ## Overview\n\n# %% [markdown]\n# This notebook provides an introduction to [DANDI:001195/0.250408.1733](https://dandiarchive.org/dandiset/001195/0.250408.1733), which contains electrophysiological recordings and calcium imaging data supporting the research on dorsal raphe nucleus (DRN) dopamine neurons and their projections to various brain regions.\n# \n# The dataset examines how DRN dopamine projections to three distinct brain regions - bed nucleus of the stria terminalis (BNST), central amygdala (CeA), and posterior basolateral amygdala (BLP) - mediate different aspects of social behavior and affective states.\n\n# %% [markdown]\n# In this notebook, we will:\n# \n# 1. Explore the Dandiset metadata\n# 2. Browse the available NWB files \n# 3. Examine the structure of intracellular electrophysiology recordings\n# 4. Visualize current-clamp response data\n# 5. Compare stimulus and response relationships\n\n# %% [markdown]\n# ## Required Packages\n\n# %%\nimport pynwb\nimport h5py\nimport remfile\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom dandi.dandiapi import DandiAPIClient\nimport pandas as pd\nfrom datetime import datetime\n\n# %% [markdown]\n# ## Exploring Dandiset Metadata\n\n# %%\n# Initialize DANDI client and get metadata\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(\"001195\", \"0.250408.1733\")\nmetadata = dandiset.get_raw_metadata()\n\nprint(f\"Dandiset name: {metadata['name']}\")\nprint(f\"Dandiset URL: {metadata['url']}\")\nprint(f\"DOI: {metadata['doi']}\")\nprint(f\"Version: {metadata['version']}\")\n\n# %% [markdown]\n# Let's look at key metadata fields that describe the research focus:\n\n# %%\n# Display subject information\nprint(\"About:\")\nfor item in metadata.get('about', []):\n    print(f\"- {item.get('name', 'N/A')}\")\n\nprint(\"\\nKeywords:\")\nfor keyword in metadata.get('keywords', []):\n    print(f\"- {keyword}\")\n\nprint(\"\\nStudy Target Summary:\")\nfor target in metadata.get('studyTarget', []):\n    # Truncate long descriptions for display\n    description = target[:200] + \"...\" if len(target) > 200 else target\n    print(f\"- {description}\")\n\n# %% [markdown]\n# ## Exploring NWB Files in the Dandiset\n\n# %%\n# Get a list of all assets\nassets = list(dandiset.get_assets())\nprint(f\"Total number of assets: {len(assets)}\")\n\n# Filter for NWB files\nnwb_files = [asset for asset in assets if asset.path.endswith('.nwb')]\nprint(f\"Number of NWB files: {len(nwb_files)}\")\n\n# Display the first 10 NWB files\nprint(\"\\nSample of NWB files:\")\nfor i, nwb_file in enumerate(nwb_files[:10]):\n    print(f\"{i+1}. {nwb_file.path}\")\n\n# %% [markdown]\n# Let's categorize the files based on their naming patterns to understand the data organization:\n\n# %%\n# Extract information from filenames\nfile_info = []\nfor asset in nwb_files:\n    parts = asset.path.split('/')\n    filename = parts[-1]\n    components = filename.split('_')\n    \n    subject_id = components[0] if len(components) > 0 else 'unknown'\n    session_id = components[1] if len(components) > 1 else 'unknown'\n    remaining = '_'.join(components[2:]) if len(components) > 2 else 'unknown'\n    \n    file_info.append({\n        'path': asset.path,\n        'subject_id': subject_id,\n        'session_id': session_id,\n        'details': remaining,\n        'size_bytes': asset.size\n    })\n\n# Convert to DataFrame for analysis\ndf_files = pd.DataFrame(file_info)\n\n# Show distribution by subject\nsubject_counts = df_files['subject_id'].value_counts()\nprint(\"Number of files per subject:\")\nprint(subject_counts.head(10))\n\n# %% [markdown]\n# ## Loading and Examining an Intracellular Electrophysiology Recording\n\n# %% [markdown]\n# Let's load one of the NWB files to explore its structure. We'll examine the intracellular electrophysiology recording (icephys) data.\n\n# %%\n# Select an NWB file to examine\nfile_to_examine = \"sub-23/sub-23_ses-20150324T134114_slice-slice-1_cell-C1_icephys.nwb\"\n\n# Find the asset by path\nasset = next(dandiset.get_assets_by_glob(file_to_examine))\nurl = asset.download_url\n\n# Use remfile to stream the data rather than downloading it\nremote_file = remfile.File(url)\nh5_file = h5py.File(remote_file)\nio = pynwb.NWBHDF5IO(file=h5_file)\nnwb = io.read()\n\n# %% [markdown]\n# Let's examine the basic data structure and metadata of this NWB file:\n\n# %%\n# Print basic information about the file\nprint(f\"Session ID: {nwb.identifier}\")\nprint(f\"Session Description: {nwb.session_description}\")\nprint(f\"Session Start Time: {nwb.session_start_time}\")\nprint(f\"Experimenter: {nwb.experimenter}\")\nprint(f\"Lab: {nwb.lab}\")\nprint(f\"Institution: {nwb.institution}\")\n\n# Subject information\nsubject = nwb.subject\nprint(\"\\nSubject Information:\")\nprint(f\"Subject ID: {subject.subject_id}\")\nprint(f\"Age: {subject.age}\")\nprint(f\"Sex: {subject.sex}\")\nprint(f\"Species: {subject.species}\")\nprint(f\"Genotype: {subject.genotype}\")\nprint(f\"Strain: {subject.strain}\")\nprint(f\"Description: {subject.description}\")\n\n# %% [markdown]\n# ### Exploring the Intracellular Electrophysiology Data Structure\n\n# %%\n# Get information about the electrodes used in the recording\nprint(\"Intracellular Electrodes:\")\nfor electrode_id, electrode in nwb.icephys_electrodes.items():\n    print(f\"  {electrode_id}:\")\n    print(f\"    Description: {electrode.description}\")\n    print(f\"    Device: {electrode.device.name}\")\n\n# Examine the DANDI-specific metadata\nif hasattr(nwb, 'lab_meta_data') and 'DandiIcephysMetadata' in nwb.lab_meta_data:\n    dandi_meta = nwb.lab_meta_data['DandiIcephysMetadata']\n    print(\"\\nDANDI Icephys Metadata:\")\n    print(f\"  Cell ID: {dandi_meta.cell_id}\")\n    print(f\"  Slice ID: {dandi_meta.slice_id}\")\n    print(f\"  Targeted Layer: {dandi_meta.targeted_layer}\")\n    print(f\"  Inferred Layer: {dandi_meta.inferred_layer}\")\n\n# %% [markdown]\n# Let's look at the structure of the acquisition (response) data:\n\n# %%\n# List the acquisition (response) data series\nprint(\"Acquisition (Response) Data Series:\")\nfor i, (series_name, series) in enumerate(nwb.acquisition.items()):\n    if i >= 5:  # Limit to first 5 for brevity\n        print(f\"  ... and {len(nwb.acquisition) - 5} more series\")\n        break\n    print(f\"  {series_name}:\")\n    print(f\"    Type: {type(series).__name__}\")\n    print(f\"    Description: {series.description[:100]}...\" if len(series.description) > 100 else f\"    Description: {series.description}\")\n    print(f\"    Rate: {series.rate} Hz\")\n    print(f\"    Unit: {series.unit}\")\n\n# %% [markdown]\n# And let's examine the stimulus data:\n\n# %%\n# List the stimulus data series\nprint(\"Stimulus Data Series:\")\nfor i, (series_name, series) in enumerate(nwb.stimulus.items()):\n    if i >= 5:  # Limit to first 5 for brevity\n        print(f\"  ... and {len(nwb.stimulus) - 5} more series\")\n        break\n    print(f\"  {series_name}:\")\n    print(f\"    Type: {type(series).__name__}\")\n    print(f\"    Description: {series.description[:100]}...\" if len(series.description) > 100 else f\"    Description: {series.description}\")\n    print(f\"    Rate: {series.rate} Hz\")\n    print(f\"    Unit: {series.unit}\")\n\n# %% [markdown]\n# Let's look at the relationship between stimulus and recordings using the icephys tables:\n\n# %%\n# Look at the structure of intracellular recordings tables\nprint(\"Intracellular Recordings Table:\")\ntry:\n    icr_df = nwb.intracellular_recordings.to_dataframe()\n    print(f\"  Number of recordings: {len(icr_df)}\")\nexcept:\n    print(\"  Could not convert to dataframe\")\n\nprint(\"\\nSimultaneous Recordings Table:\")\ntry:\n    sim_df = nwb.icephys_simultaneous_recordings.to_dataframe()\n    print(f\"  Number of simultaneous recording groups: {len(sim_df)}\")\n    print(f\"  Columns: {sim_df.columns.tolist()}\")\nexcept:\n    print(\"  Could not convert to dataframe\")\n\nprint(\"\\nSequential Recordings Table:\")\ntry:\n    seq_df = nwb.icephys_sequential_recordings.to_dataframe()\n    print(f\"  Number of sequential recording groups: {len(seq_df)}\")\n    print(f\"  Columns: {seq_df.columns.tolist()}\")\nexcept:\n    print(\"  Could not convert to dataframe\")\n\n# %% [markdown]\n# ## Visualizing the Electrophysiology Data\n\n# %% [markdown]\n# Now let's visualize the current clamp responses to different stimulus intensities. We'll examine the data from specific episodes.\n\n# %%\n# Function to extract data from a specific stimulus-response pair\ndef extract_stimulus_response_data(episode_num, channel=0):\n    stim_name = f\"stimulus-{episode_num:02d}-ch-{channel}\"\n    resp_name = f\"current_clamp-response-{episode_num:02d}-ch-{channel}\"\n    \n    if stim_name in nwb.stimulus and resp_name in nwb.acquisition:\n        stimulus = nwb.stimulus[stim_name]\n        response = nwb.acquisition[resp_name]\n        \n        # Get data and apply conversion\n        stim_data = stimulus.data[:]\n        resp_data = response.data[:] * response.conversion\n        \n        # Create time array\n        dt = 1.0 / stimulus.rate\n        time = np.arange(len(stim_data)) * dt\n        \n        return time, stim_data, resp_data, stimulus.unit, response.unit\n    else:\n        return None, None, None, None, None\n\n# Plot the first few episodes\nplt.figure(figsize=(12, 10))\n\n# Plot multiple episodes\nfor i in range(1, 5):  # First 4 episodes\n    time, stim_data, resp_data, stim_unit, resp_unit = extract_stimulus_response_data(i)\n    \n    if time is not None:\n        # Calculate current value based on episode number\n        current_value = (i-1) * 20 - 120  # -120pA baseline with 20pA steps\n        \n        # Create subplots\n        plt.subplot(4, 2, 2*i-1)\n        plt.plot(time, stim_data, 'b-')\n        plt.title(f\"Episode {i}: Stimulus ({current_value} pA)\")\n        plt.ylabel(f\"Current ({stim_unit})\")\n        plt.grid(True, alpha=0.3)\n        \n        plt.subplot(4, 2, 2*i)\n        plt.plot(time, resp_data, 'r-')\n        plt.title(f\"Episode {i}: Response\")\n        plt.ylabel(f\"Voltage ({resp_unit})\")\n        plt.grid(True, alpha=0.3)\n        \n        # Only add x-label to the bottom plots\n        if i == 4:\n            plt.xlabel(\"Time (s)\")\n    else:\n        print(f\"Data for episode {i} not found\")\n\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# Let's create a comparison plot that shows the different response patterns across multiple current steps:\n\n# %%\n# Plot responses from multiple episodes on the same axes\nplt.figure(figsize=(10, 6))\n\n# Select episodes with different current steps to visualize\nepisodes_to_plot = [1, 5, 9, 13, 17, 21]  # Different current values\ncolors = plt.cm.viridis(np.linspace(0, 1, len(episodes_to_plot)))\n\nfor idx, episode in enumerate(episodes_to_plot):\n    time, _, resp_data, _, resp_unit = extract_stimulus_response_data(episode)\n    \n    if time is not None:\n        current_value = (episode-1) * 20 - 120  # Calculate current value\n        plt.plot(time, resp_data, color=colors[idx], \n                 label=f\"Episode {episode}: {current_value} pA\")\n    \nplt.xlabel('Time (s)')\nplt.ylabel(f'Membrane Potential ({resp_unit})')\nplt.title('Membrane Potential Response to Different Current Steps')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# ### Analyzing Response Properties\n\n# %% [markdown]\n# Now let's analyze the voltage responses to different current injections to better understand the electrophysiological properties of this cell:\n\n# %%\n# Function to extract key metrics from responses\ndef extract_response_metrics(max_episodes=20):\n    \"\"\"Extract key metrics from current clamp responses\"\"\"\n    \n    # Initialize arrays to store results\n    current_values = []\n    peak_values = []\n    steady_state_values = []\n    \n    for episode in range(1, max_episodes+1):\n        time, stim_data, resp_data, _, _ = extract_stimulus_response_data(episode)\n        \n        if time is None or resp_data is None:\n            continue\n        \n        # Current value for this episode\n        current_value = (episode-1) * 20 - 120\n        \n        # Assuming stimulus is applied from 0.4s to 1.4s (based on visualization)\n        # Find indices for baseline, peak response, and steady-state\n        baseline_idx = slice(int(0.1 * len(time)), int(0.4 * len(time)))\n        response_idx = slice(int(0.4 * len(time)), int(1.4 * len(time)))\n        steady_idx = slice(int(1.3 * len(time)), int(1.4 * len(time)))\n        \n        # Calculate metrics\n        baseline_v = np.mean(resp_data[baseline_idx])\n        response_v = resp_data[response_idx]\n        \n        # For positive currents, find max (depolarization)\n        # For negative currents, find min (hyperpolarization)\n        if current_value >= 0:\n            peak_v = np.max(response_v) - baseline_v\n        else:\n            peak_v = np.min(response_v) - baseline_v\n        \n        # Calculate steady-state response\n        steady_v = np.mean(resp_data[steady_idx]) - baseline_v\n        \n        # Store results\n        current_values.append(current_value)\n        peak_values.append(peak_v)\n        steady_state_values.append(steady_v)\n    \n    return current_values, peak_values, steady_state_values\n\n# Extract metrics and create I-V curve\ncurrents, peaks, steady_states = extract_response_metrics(max_episodes=25)\n\n# Plot I-V relationship\nplt.figure(figsize=(10, 6))\nplt.plot(currents, peaks, 'o-', label='Peak Response')\nplt.plot(currents, steady_states, 's-', label='Steady-State Response')\n\n# Add zero lines\nplt.axhline(y=0, color='k', linestyle='--', alpha=0.3)\nplt.axvline(x=0, color='k', linestyle='--', alpha=0.3)\n\nplt.xlabel('Current Injection (pA)')\nplt.ylabel('Voltage Response (V)')\nplt.title('Current-Voltage (I-V) Relationship')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# Let's also analyze the spike activity in response to different current injections:\n\n# %%\n# Function to detect action potentials in voltage traces\ndef detect_spikes(voltage, time, threshold=0.02, min_interval=0.001):\n    \"\"\"\n    Detect spikes (action potentials) in a voltage trace\n    \n    Parameters:\n    voltage - voltage trace\n    time - corresponding time points\n    threshold - voltage threshold for spike detection (V)\n    min_interval - minimum time between spikes (s)\n    \n    Returns:\n    spike_times - times of detected spikes\n    \"\"\"\n    # Compute derivative to detect rapid voltage changes\n    dv = np.diff(voltage)\n    \n    # Find threshold crossings with high dv/dt\n    threshold_crossings = []\n    for i in range(1, len(dv)-1):\n        if dv[i] > threshold and voltage[i] > -0.03:  # Typical AP threshold\n            threshold_crossings.append(i)\n    \n    # Filter out multiple crossings for the same spike\n    spike_indices = []\n    if len(threshold_crossings) > 0:\n        spike_indices = [threshold_crossings[0]]\n        for i in range(1, len(threshold_crossings)):\n            if time[threshold_crossings[i]] - time[spike_indices[-1]] > min_interval:\n                spike_indices.append(threshold_crossings[i])\n    \n    return [time[i] for i in spike_indices]\n\n# Create a raster plot of spikes for different current injections\nplt.figure(figsize=(10, 6))\n\n# Track if we found any spikes\nspikes_found = False\n\n# Analyze episodes\nfor episode in range(1, 25):  # Analyze first 25 episodes\n    time, _, resp_data, _, _ = extract_stimulus_response_data(episode)\n    \n    if time is None or resp_data is None:\n        continue\n    \n    # Calculate current value\n    current_value = (episode-1) * 20 - 120\n    \n    # Detect spikes\n    spike_times = detect_spikes(resp_data, time)\n    \n    # Plot spike times as vertical lines\n    if spike_times:\n        spikes_found = True\n        plt.plot(spike_times, [episode] * len(spike_times), 'k|', ms=20, mew=1)\n    \n    # Annotate with current value\n    plt.text(max(time) + 0.05, episode, f\"{current_value} pA\", va='center')\n\n# Indicate stimulus period\nplt.axvspan(0.4, 1.4, color='lightgray', alpha=0.3, label='Stimulus Period')\n\nplt.xlabel('Time (s)')\nplt.ylabel('Episode Number')\nplt.title('Spike Raster Plot Across Different Current Injections')\nplt.xlim(-0.1, 3.1)\nplt.ylim(0.5, 25.5)\nplt.grid(True, alpha=0.3, axis='y')\n\nif not spikes_found:\n    plt.text(1.5, 12.5, \"No spikes detected\", fontsize=14, ha='center')\n\nplt.legend(loc='upper right')\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# Finally, let's look at the firing frequency vs. current intensity (F-I curve) for our cell:\n\n# %%\n# Function to calculate firing frequency for each current injection\ndef calculate_firing_rates(max_episodes=25):\n    \"\"\"Calculate firing rates for different current injections\"\"\"\n    \n    current_values = []\n    firing_rates = []\n    \n    for episode in range(1, max_episodes+1):\n        time, _, resp_data, _, _ = extract_stimulus_response_data(episode)\n        \n        if time is None or resp_data is None:\n            continue\n        \n        # Calculate current value\n        current_value = (episode-1) * 20 - 120\n        \n        # Detect spikes during stimulus period (0.4s to 1.4s)\n        stim_start_idx = np.argmin(np.abs(time - 0.4))\n        stim_end_idx = np.argmin(np.abs(time - 1.4))\n        \n        stim_time = time[stim_start_idx:stim_end_idx]\n        stim_resp = resp_data[stim_start_idx:stim_end_idx]\n        \n        if len(stim_time) > 0:\n            spike_times = detect_spikes(stim_resp, stim_time)\n            \n            # Calculate firing rate (Hz)\n            stim_duration = stim_time[-1] - stim_time[0]\n            firing_rate = len(spike_times) / stim_duration if stim_duration > 0 else 0\n            \n            current_values.append(current_value)\n            firing_rates.append(firing_rate)\n    \n    return current_values, firing_rates\n\n# Calculate firing rates\ncurrent_values, firing_rates = calculate_firing_rates()\n\n# Plot F-I curve\nplt.figure(figsize=(8, 6))\nplt.plot(current_values, firing_rates, 'o-', color='purple')\nplt.xlabel('Current Injection (pA)')\nplt.ylabel('Firing Rate (Hz)')\nplt.title('Firing Frequency vs. Current (F-I) Relationship')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n# %% [markdown]\n# ## Summary\n\n# %% [markdown]\n# In this notebook, we explored Dandiset 001195, which contains electrophysiological recordings from dorsal raphe nucleus (DRN) dopamine neurons and their projections to various brain regions. We:\n# \n# 1. Examined the metadata to understand the scientific context of the dataset\n# 2. Explored the structure of the NWB files within the dandiset\n# 3. Analyzed intracellular electrophysiology data, focusing on current-clamp recordings\n# 4. Visualized responses to different stimulus intensities\n# 5. Created analysis plots showing current-voltage relationships and spiking patterns\n# \n# Future explorations could include:\n# - Comparing recordings across different brain regions (BNST, CeA, BLP)\n# - Analyzing calcium imaging data included in the dataset\n# - Examining response differences between experimental conditions\n# - Correlating electrophysiological properties with behavioral outcomes\n</notebook>"
  }
]