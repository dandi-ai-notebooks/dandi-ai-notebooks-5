[
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is metadata about Dandiset 001359 version 0.250401.1603."
      },
      {
        "type": "text",
        "text": "{\n  \"id\": \"DANDI:001359/0.250401.1603\",\n  \"doi\": \"10.48324/dandi.001359/0.250401.1603\",\n  \"url\": \"https://dandiarchive.org/dandiset/001359/0.250401.1603\",\n  \"name\": \"20250331_AIBS_Patchseq_human\",\n  \"about\": [],\n  \"access\": [\n    {\n      \"status\": \"dandi:OpenAccess\",\n      \"schemaKey\": \"AccessRequirements\"\n    }\n  ],\n  \"license\": [\n    \"spdx:CC-BY-4.0\"\n  ],\n  \"version\": \"0.250401.1603\",\n  \"@context\": \"https://raw.githubusercontent.com/dandi/schema/master/releases/0.6.9/context.json\",\n  \"citation\": \"Gonzalez, Limary; Allen Institute for Brain Science; National Institute of Mental Health;  Kalmbach, Brian; Dalley, Rachel; Lein, Ed; Lee, Brian (2025) 20250331_AIBS_Patchseq_human (Version 0.250401.1603) [Data set]. DANDI Archive. https://doi.org/10.48324/dandi.001359/0.250401.1603\",\n  \"keywords\": [\n    \"Patch-seq, human, multimodal\"\n  ],\n  \"protocol\": [\n    \"https://www.protocols.io/view/patch-seq-recording-and-extraction-8epv51n45l1b/v3\"\n  ],\n  \"schemaKey\": \"Dandiset\",\n  \"identifier\": \"DANDI:001359\",\n  \"repository\": \"https://dandiarchive.org\",\n  \"contributor\": [\n    {\n      \"name\": \"Gonzalez, Limary\",\n      \"email\": \"limary.gonzalez@alleninstitute.org\",\n      \"roleName\": [\n        \"dcite:ContactPerson\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0009-0009-0306-0002\",\n      \"affiliation\": [],\n      \"includeInCitation\": true\n    },\n    {\n      \"url\": \"https://alleninstitute.org/\",\n      \"name\": \"Allen Institute for Brain Science\",\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/00dcv1019\",\n      \"awardNumber\": \"UM1MH130981\",\n      \"includeInCitation\": true\n    },\n    {\n      \"url\": \"https://www.nimh.nih.gov/\",\n      \"name\": \"National Institute of Mental Health\",\n      \"roleName\": [\n        \"dcite:Funder\"\n      ],\n      \"schemaKey\": \"Organization\",\n      \"identifier\": \"https://ror.org/04xeg9z08\",\n      \"awardNumber\": \"UM1MH130981\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \" Kalmbach, Brian\",\n      \"email\": \"briank@alleninstitute.org\",\n      \"roleName\": [\n        \"dcite:ContactPerson\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0000-0003-3136-8097\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"Dalley, Rachel\",\n      \"email\": \"racheld@alleninstitute.org\",\n      \"roleName\": [\n        \"dcite:ProjectMember\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0000-0001-7461-7845\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"Lein, Ed\",\n      \"email\": \"edl@alleninstitute.org\",\n      \"roleName\": [\n        \"dcite:ProjectLeader\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0000-0001-9012-6552\",\n      \"includeInCitation\": true\n    },\n    {\n      \"name\": \"Lee, Brian\",\n      \"email\": \"brianle@alleninstitute.org\",\n      \"roleName\": [\n        \"dcite:ContactPerson\"\n      ],\n      \"schemaKey\": \"Person\",\n      \"identifier\": \"0000-0002-3210-5638\",\n      \"includeInCitation\": true\n    }\n  ],\n  \"dateCreated\": \"2025-03-12T20:32:20.781863+00:00\",\n  \"description\": \"HMBA Lein PatchSeq upload (human) (Q1 2025)\",\n  \"publishedBy\": {\n    \"id\": \"urn:uuid:97fe7dc2-77c5-4f95-80ae-da786cfe8940\",\n    \"name\": \"DANDI publish\",\n    \"endDate\": \"2025-04-01T16:03:13.020238+00:00\",\n    \"schemaKey\": \"PublishActivity\",\n    \"startDate\": \"2025-04-01T16:03:13.020238+00:00\",\n    \"wasAssociatedWith\": [\n      {\n        \"id\": \"urn:uuid:523c58a9-9ee4-41c2-937d-c6d2f639f424\",\n        \"name\": \"DANDI API\",\n        \"version\": \"0.1.0\",\n        \"schemaKey\": \"Software\",\n        \"identifier\": \"RRID:SCR_017571\"\n      }\n    ]\n  },\n  \"studyTarget\": [\n    \"Multimodal classifcation of cell types in the human.\"\n  ],\n  \"assetsSummary\": {\n    \"species\": [\n      {\n        \"name\": \"Homo sapiens - Human\",\n        \"schemaKey\": \"SpeciesType\",\n        \"identifier\": \"http://purl.obolibrary.org/obo/NCBITaxon_9606\"\n      }\n    ],\n    \"approach\": [\n      {\n        \"name\": \"electrophysiological approach\",\n        \"schemaKey\": \"ApproachType\"\n      }\n    ],\n    \"schemaKey\": \"AssetsSummary\",\n    \"dataStandard\": [\n      {\n        \"name\": \"Neurodata Without Borders (NWB)\",\n        \"schemaKey\": \"StandardsType\",\n        \"identifier\": \"RRID:SCR_015242\"\n      }\n    ],\n    \"numberOfBytes\": 23778635304,\n    \"numberOfFiles\": 391,\n    \"numberOfSubjects\": 33,\n    \"variableMeasured\": [\n      \"CurrentClampStimulusSeries\",\n      \"ProcessingModule\",\n      \"CurrentClampSeries\",\n      \"VoltageClampSeries\",\n      \"VoltageClampStimulusSeries\"\n    ],\n    \"measurementTechnique\": [\n      {\n        \"name\": \"voltage clamp technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      },\n      {\n        \"name\": \"current clamp technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      },\n      {\n        \"name\": \"analytical technique\",\n        \"schemaKey\": \"MeasurementTechniqueType\"\n      }\n    ]\n  },\n  \"datePublished\": \"2025-04-01T16:03:13.020238+00:00\",\n  \"schemaVersion\": \"0.6.9\",\n  \"ethicsApproval\": [],\n  \"wasGeneratedBy\": [],\n  \"relatedResource\": [],\n  \"manifestLocation\": [\n    \"https://dandiarchive.s3.amazonaws.com/dandisets/001359/0.250401.1603/assets.yaml\"\n  ]\n}"
      }
    ]
  },
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is a listing of some of the files in the Dandiset."
      },
      {
        "type": "text",
        "text": "sub-1203384279/sub-1203384279_ses-1207984257_icephys.nwb\nsub-1203384279/sub-1203384279_ses-1207304122_icephys.nwb\nsub-1203384279/sub-1203384279_ses-1207262032_icephys.nwb\nsub-1203384279/sub-1203384279_ses-1207418023_icephys.nwb\nsub-1203384279/sub-1203384279_ses-1208065964_icephys.nwb\nsub-1213383385/sub-1213383385_ses-1213430531_icephys.nwb\nsub-1211237280/sub-1211237280_ses-1211340847_icephys.nwb\nsub-1213383385/sub-1213383385_ses-1213420947_icephys.nwb\nsub-1213383385/sub-1213383385_ses-1213591749_icephys.nwb\nsub-1213383385/sub-1213383385_ses-1213661643_icephys.nwb"
      }
    ]
  },
  {
    "role": "system",
    "content": [
      {
        "type": "text",
        "text": "The following is metadata and usage information about the file sub-1203384279/sub-1203384279_ses-1207984257_icephys.nwb."
      },
      {
        "type": "text",
        "text": "\nimport pynwb\nimport h5py\nimport remfile\n\n# Load\nfrom dandi.dandiapi import DandiAPIClient\n\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(\"001359\", \"0.250401.1603\")\nurl = next(dandiset.get_assets_by_glob(\"sub-1203384279/sub-1203384279_ses-1207984257_icephys.nwb\")).download_url\n\nremote_file = remfile.File(url)\nh5_file = h5py.File(remote_file)\nio = pynwb.NWBHDF5IO(file=h5_file)\nnwb = io.read()\n\nnwb # (NWBFile)\nnwb.session_description # (str) PLACEHOLDER\nnwb.identifier # (str) 27b36092e3c7a2da89f6951f82bbb47f802206ed62ab21b7d58da27e04a980a3\nnwb.session_start_time # (datetime) 2022-09-07T17:13:04.880000+00:00\nnwb.timestamps_reference_time # (datetime) 2022-09-07T17:13:04.880000+00:00\nnwb.file_create_date # (list) [datetime.datetime(2022, 9, 7, 10, 49, 37, 115000, tzinfo=tzoffset(None, -25200)), datetime.datetime(2022, 9, 7, 10, 49, 37, tzinfo=tzoffset(None, -25200)), datetime.datetime(2022, 9, 7, 10, 49, 37, tzinfo=tzoffset(None, -25200)), datetime.datetime(2022, 9, 7, 10, 50, 9, tzinfo=tzoffset(None, -25200))]\nnwb.icephys_electrodes # (LabelledDict)\nicephys_electrodes = nwb.icephys_electrodes\nelectrode_0 = icephys_electrodes[\"electrode_0\"]\nelectrode_0 # (IntracellularElectrode)\nelectrode_0.description # (str) Headstage 0\nelectrode_0.device # (Device)\nelectrode_0.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\nnwb.acquisition # (LabelledDict)\nacquisition = nwb.acquisition\ndata_00000_AD0 = acquisition[\"data_00000_AD0\"]\ndata_00000_AD0 # (VoltageClampSeries)\ndata_00000_AD0.starting_time # (float64) 12.917999744415283\ndata_00000_AD0.rate # (float32)\ndata_00000_AD0.resolution # (float32)\ndata_00000_AD0.comments # (str) HS#0:Fast compensation capacitance: 0.00 F\\nHS#0:Slow compensation capacitance: 0.00 F\\nHS#0:Fast...\ndata_00000_AD0.description # (str) PLACEHOLDER\ndata_00000_AD0.conversion # (float32)\ndata_00000_AD0.offset # (float) 0.0\ndata_00000_AD0.unit # (str) amperes\ndata_00000_AD0.data # (Dataset) shape (161000,); dtype float32\n# data_00000_AD0.data[:] # Access all data\n# data_00000_AD0.data[0:n] # Access first n elements\ndata_00000_AD0.starting_time_unit # (str) seconds\ndata_00000_AD0.gain # (float32)\ndata_00000_AD0.stimulus_description # (str) EXTPSMOKET180424_DA_0\ndata_00000_AD0.sweep_number # (uint32)\ndata_00000_AD0.capacitance_fast # (float32)\ndata_00000_AD0.capacitance_slow # (float32)\ndata_00000_AD0.electrode # (IntracellularElectrode)\ndata_00000_AD0.electrode.description # (str) Headstage 0\ndata_00000_AD0.electrode.device # (Device)\ndata_00000_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00001_AD0 = acquisition[\"data_00001_AD0\"]\ndata_00001_AD0 # (VoltageClampSeries)\ndata_00001_AD0.starting_time # (float64) 13.698999881744385\ndata_00001_AD0.rate # (float32)\ndata_00001_AD0.resolution # (float32)\ndata_00001_AD0.comments # (str) HS#0:TP Auto: On\\nHS#0:Set Sweep Count: 1.00 \\nAsync AD 2 [Set Temperature]: 37.09 degC\\n\\nHigh p...\ndata_00001_AD0.description # (str) PLACEHOLDER\ndata_00001_AD0.conversion # (float32)\ndata_00001_AD0.offset # (float) 0.0\ndata_00001_AD0.unit # (str) amperes\ndata_00001_AD0.data # (Dataset) shape (161000,); dtype float32\n# data_00001_AD0.data[:] # Access all data\n# data_00001_AD0.data[0:n] # Access first n elements\ndata_00001_AD0.starting_time_unit # (str) seconds\ndata_00001_AD0.gain # (float32)\ndata_00001_AD0.stimulus_description # (str) EXTPSMOKET180424_DA_0\ndata_00001_AD0.sweep_number # (uint32)\ndata_00001_AD0.capacitance_fast # (float32)\ndata_00001_AD0.capacitance_slow # (float32)\ndata_00001_AD0.electrode # (IntracellularElectrode)\ndata_00001_AD0.electrode.description # (str) Headstage 0\ndata_00001_AD0.electrode.device # (Device)\ndata_00001_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00002_AD0 = acquisition[\"data_00002_AD0\"]\ndata_00002_AD0 # (VoltageClampSeries)\ndata_00002_AD0.starting_time # (float64) 14.503999710083008\ndata_00002_AD0.rate # (float32)\ndata_00002_AD0.resolution # (float32)\ndata_00002_AD0.comments # (str) HS#0:Set Sweep Count: 2.00 \\nAsync AD 2 [Set Temperature]: 37.06 degC\\n\\nHigh precision sweep sta...\ndata_00002_AD0.description # (str) PLACEHOLDER\ndata_00002_AD0.conversion # (float32)\ndata_00002_AD0.offset # (float) 0.0\ndata_00002_AD0.unit # (str) amperes\ndata_00002_AD0.data # (Dataset) shape (161000,); dtype float32\n# data_00002_AD0.data[:] # Access all data\n# data_00002_AD0.data[0:n] # Access first n elements\ndata_00002_AD0.starting_time_unit # (str) seconds\ndata_00002_AD0.gain # (float32)\ndata_00002_AD0.stimulus_description # (str) EXTPSMOKET180424_DA_0\ndata_00002_AD0.sweep_number # (uint32)\ndata_00002_AD0.capacitance_fast # (float32)\ndata_00002_AD0.capacitance_slow # (float32)\ndata_00002_AD0.electrode # (IntracellularElectrode)\ndata_00002_AD0.electrode.description # (str) Headstage 0\ndata_00002_AD0.electrode.device # (Device)\ndata_00002_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00003_AD0 = acquisition[\"data_00003_AD0\"]\ndata_00003_AD0 # (VoltageClampSeries)\ndata_00003_AD0.starting_time # (float64) 525.7560000419617\ndata_00003_AD0.rate # (float32)\ndata_00003_AD0.resolution # (float32)\ndata_00003_AD0.comments # (str) HS#0:Set Sweep Count: 0.00 \\nRepeated Acq Cycle ID: 3174623.00 \\nHS#0:Stim Wave Checksum: 3854609...\ndata_00003_AD0.description # (str) PLACEHOLDER\ndata_00003_AD0.conversion # (float32)\ndata_00003_AD0.offset # (float) 0.0\ndata_00003_AD0.unit # (str) amperes\ndata_00003_AD0.data # (Dataset) shape (161000,); dtype float32\n# data_00003_AD0.data[:] # Access all data\n# data_00003_AD0.data[0:n] # Access first n elements\ndata_00003_AD0.starting_time_unit # (str) seconds\ndata_00003_AD0.gain # (float32)\ndata_00003_AD0.stimulus_description # (str) EXTPINBATH180424_DA_0\ndata_00003_AD0.sweep_number # (uint32)\ndata_00003_AD0.capacitance_fast # (float32)\ndata_00003_AD0.capacitance_slow # (float32)\ndata_00003_AD0.electrode # (IntracellularElectrode)\ndata_00003_AD0.electrode.description # (str) Headstage 0\ndata_00003_AD0.electrode.device # (Device)\ndata_00003_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00004_AD0 = acquisition[\"data_00004_AD0\"]\ndata_00004_AD0 # (VoltageClampSeries)\ndata_00004_AD0.starting_time # (float64) 585.3480000495911\ndata_00004_AD0.rate # (float32)\ndata_00004_AD0.resolution # (float32)\ndata_00004_AD0.comments # (str) HS#0:Stim set length: 12277000.00 \\nRepeated Acq Cycle ID: 6121437.00 \\nHS#0:Stim Wave Checksum: ...\ndata_00004_AD0.description # (str) PLACEHOLDER\ndata_00004_AD0.conversion # (float32)\ndata_00004_AD0.offset # (float) 0.0\ndata_00004_AD0.unit # (str) amperes\ndata_00004_AD0.data # (Dataset) shape (12297000,); dtype float32\n# data_00004_AD0.data[:] # Access all data\n# data_00004_AD0.data[0:n] # Access first n elements\ndata_00004_AD0.starting_time_unit # (str) seconds\ndata_00004_AD0.gain # (float32)\ndata_00004_AD0.stimulus_description # (str) EXTPCllATT180424_DA_0\ndata_00004_AD0.sweep_number # (uint32)\ndata_00004_AD0.capacitance_fast # (float32)\ndata_00004_AD0.capacitance_slow # (float32)\ndata_00004_AD0.electrode # (IntracellularElectrode)\ndata_00004_AD0.electrode.description # (str) Headstage 0\ndata_00004_AD0.electrode.device # (Device)\ndata_00004_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00005_AD0 = acquisition[\"data_00005_AD0\"]\ndata_00005_AD0 # (VoltageClampSeries)\ndata_00005_AD0.starting_time # (float64) 702.1389999389648\ndata_00005_AD0.rate # (float32)\ndata_00005_AD0.resolution # (float32)\ndata_00005_AD0.comments # (str) HS#0:USER_Access Res. Smoke version: 1.00 \\nHS#0:USER_Access Res. Smoke BL QC: On\\nHS#0:USER_Acce...\ndata_00005_AD0.description # (str) PLACEHOLDER\ndata_00005_AD0.conversion # (float32)\ndata_00005_AD0.offset # (float) 0.0\ndata_00005_AD0.unit # (str) amperes\ndata_00005_AD0.data # (Dataset) shape (161000,); dtype float32\n# data_00005_AD0.data[:] # Access all data\n# data_00005_AD0.data[0:n] # Access first n elements\ndata_00005_AD0.starting_time_unit # (str) seconds\ndata_00005_AD0.gain # (float32)\ndata_00005_AD0.stimulus_description # (str) EXTPBREAKN180424_DA_0\ndata_00005_AD0.sweep_number # (uint32)\ndata_00005_AD0.capacitance_fast # (float32)\ndata_00005_AD0.capacitance_slow # (float32)\ndata_00005_AD0.electrode # (IntracellularElectrode)\ndata_00005_AD0.electrode.description # (str) Headstage 0\ndata_00005_AD0.electrode.device # (Device)\ndata_00005_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00006_AD0 = acquisition[\"data_00006_AD0\"]\ndata_00006_AD0 # (CurrentClampSeries)\ndata_00006_AD0.starting_time # (float64) 788.4270000457764\ndata_00006_AD0.rate # (float32)\ndata_00006_AD0.resolution # (float32)\ndata_00006_AD0.comments # (str) HS#0:DA Gain: 400.00 \\nHS#0:AD Gain: 0.01 \\nDelay onset auto: 259.07 ms\\nSampling interval multip...\ndata_00006_AD0.description # (str) PLACEHOLDER\ndata_00006_AD0.conversion # (float32)\ndata_00006_AD0.offset # (float) 0.0\ndata_00006_AD0.unit # (str) volts\ndata_00006_AD0.data # (Dataset) shape (312953,); dtype float32\n# data_00006_AD0.data[:] # Access all data\n# data_00006_AD0.data[0:n] # Access first n elements\ndata_00006_AD0.starting_time_unit # (str) seconds\ndata_00006_AD0.gain # (float32)\ndata_00006_AD0.stimulus_description # (str) X0NRMP_DA_0\ndata_00006_AD0.sweep_number # (uint32)\ndata_00006_AD0.bridge_balance # (float32)\ndata_00006_AD0.capacitance_compensation # (float32)\ndata_00006_AD0.electrode # (IntracellularElectrode)\ndata_00006_AD0.electrode.description # (str) Headstage 0\ndata_00006_AD0.electrode.device # (Device)\ndata_00006_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00007_AD0 = acquisition[\"data_00007_AD0\"]\ndata_00007_AD0 # (CurrentClampSeries)\ndata_00007_AD0.starting_time # (float64) 807.9530000686646\ndata_00007_AD0.rate # (float32)\ndata_00007_AD0.resolution # (float32)\ndata_00007_AD0.comments # (str) HS#0:Stim Scale Factor: -30.00 \\nIndexing: On\\nHS#0:Stim set length: 175000.00 \\nRepeated Acq Cyc...\ndata_00007_AD0.description # (str) PLACEHOLDER\ndata_00007_AD0.conversion # (float32)\ndata_00007_AD0.offset # (float) 0.0\ndata_00007_AD0.unit # (str) volts\ndata_00007_AD0.data # (Dataset) shape (187953,); dtype float32\n# data_00007_AD0.data[:] # Access all data\n# data_00007_AD0.data[0:n] # Access first n elements\ndata_00007_AD0.starting_time_unit # (str) seconds\ndata_00007_AD0.gain # (float32)\ndata_00007_AD0.stimulus_description # (str) X1PS_SubThresh_DA_0\ndata_00007_AD0.sweep_number # (uint32)\ndata_00007_AD0.bridge_balance # (float32)\ndata_00007_AD0.capacitance_compensation # (float32)\ndata_00007_AD0.electrode # (IntracellularElectrode)\ndata_00007_AD0.electrode.description # (str) Headstage 0\ndata_00007_AD0.electrode.device # (Device)\ndata_00007_AD0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\n# ...\n# Other fields: data_00008_AD0, data_00009_AD0, data_00010_AD0, data_00011_AD0, data_00012_AD0, data_00013_AD0, data_00014_AD0, data_00015_AD0, data_00016_AD0, data_00017_AD0, data_00018_AD0, data_00019_AD0, data_00020_AD0, data_00021_AD0, data_00022_AD0\n# ... and 43 more fields\nnwb.stimulus # (LabelledDict)\nstimulus = nwb.stimulus\ndata_00000_DA0 = stimulus[\"data_00000_DA0\"]\ndata_00000_DA0 # (VoltageClampStimulusSeries)\ndata_00000_DA0.starting_time # (float64) 12.917999744415283\ndata_00000_DA0.rate # (float32)\ndata_00000_DA0.resolution # (float32)\ndata_00000_DA0.comments # (str) HS#0:Fast compensation capacitance: 0.00 F\\nHS#0:Slow compensation capacitance: 0.00 F\\nHS#0:Fast...\ndata_00000_DA0.description # (str) PLACEHOLDER\ndata_00000_DA0.conversion # (float32)\ndata_00000_DA0.offset # (float) 0.0\ndata_00000_DA0.unit # (str) volts\ndata_00000_DA0.data # (Dataset) shape (161000,); dtype float32\n# data_00000_DA0.data[:] # Access all data\n# data_00000_DA0.data[0:n] # Access first n elements\ndata_00000_DA0.starting_time_unit # (str) seconds\ndata_00000_DA0.gain # (float32)\ndata_00000_DA0.stimulus_description # (str) EXTPSMOKET180424_DA_0\ndata_00000_DA0.sweep_number # (uint32)\ndata_00000_DA0.electrode # (IntracellularElectrode)\ndata_00000_DA0.electrode.description # (str) Headstage 0\ndata_00000_DA0.electrode.device # (Device)\ndata_00000_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00001_DA0 = stimulus[\"data_00001_DA0\"]\ndata_00001_DA0 # (VoltageClampStimulusSeries)\ndata_00001_DA0.starting_time # (float64) 13.698999881744385\ndata_00001_DA0.rate # (float32)\ndata_00001_DA0.resolution # (float32)\ndata_00001_DA0.comments # (str) HS#0:TP Auto: On\\nHS#0:Set Sweep Count: 1.00 \\nAsync AD 2 [Set Temperature]: 37.09 degC\\n\\nHigh p...\ndata_00001_DA0.description # (str) PLACEHOLDER\ndata_00001_DA0.conversion # (float32)\ndata_00001_DA0.offset # (float) 0.0\ndata_00001_DA0.unit # (str) volts\ndata_00001_DA0.data # (Dataset) shape (161000,); dtype float32\n# data_00001_DA0.data[:] # Access all data\n# data_00001_DA0.data[0:n] # Access first n elements\ndata_00001_DA0.starting_time_unit # (str) seconds\ndata_00001_DA0.gain # (float32)\ndata_00001_DA0.stimulus_description # (str) EXTPSMOKET180424_DA_0\ndata_00001_DA0.sweep_number # (uint32)\ndata_00001_DA0.electrode # (IntracellularElectrode)\ndata_00001_DA0.electrode.description # (str) Headstage 0\ndata_00001_DA0.electrode.device # (Device)\ndata_00001_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00002_DA0 = stimulus[\"data_00002_DA0\"]\ndata_00002_DA0 # (VoltageClampStimulusSeries)\ndata_00002_DA0.starting_time # (float64) 14.503999710083008\ndata_00002_DA0.rate # (float32)\ndata_00002_DA0.resolution # (float32)\ndata_00002_DA0.comments # (str) HS#0:Set Sweep Count: 2.00 \\nAsync AD 2 [Set Temperature]: 37.06 degC\\n\\nHigh precision sweep sta...\ndata_00002_DA0.description # (str) PLACEHOLDER\ndata_00002_DA0.conversion # (float32)\ndata_00002_DA0.offset # (float) 0.0\ndata_00002_DA0.unit # (str) volts\ndata_00002_DA0.data # (Dataset) shape (161000,); dtype float32\n# data_00002_DA0.data[:] # Access all data\n# data_00002_DA0.data[0:n] # Access first n elements\ndata_00002_DA0.starting_time_unit # (str) seconds\ndata_00002_DA0.gain # (float32)\ndata_00002_DA0.stimulus_description # (str) EXTPSMOKET180424_DA_0\ndata_00002_DA0.sweep_number # (uint32)\ndata_00002_DA0.electrode # (IntracellularElectrode)\ndata_00002_DA0.electrode.description # (str) Headstage 0\ndata_00002_DA0.electrode.device # (Device)\ndata_00002_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00003_DA0 = stimulus[\"data_00003_DA0\"]\ndata_00003_DA0 # (VoltageClampStimulusSeries)\ndata_00003_DA0.starting_time # (float64) 525.7560000419617\ndata_00003_DA0.rate # (float32)\ndata_00003_DA0.resolution # (float32)\ndata_00003_DA0.comments # (str) HS#0:Set Sweep Count: 0.00 \\nRepeated Acq Cycle ID: 3174623.00 \\nHS#0:Stim Wave Checksum: 3854609...\ndata_00003_DA0.description # (str) PLACEHOLDER\ndata_00003_DA0.conversion # (float32)\ndata_00003_DA0.offset # (float) 0.0\ndata_00003_DA0.unit # (str) volts\ndata_00003_DA0.data # (Dataset) shape (161000,); dtype float32\n# data_00003_DA0.data[:] # Access all data\n# data_00003_DA0.data[0:n] # Access first n elements\ndata_00003_DA0.starting_time_unit # (str) seconds\ndata_00003_DA0.gain # (float32)\ndata_00003_DA0.stimulus_description # (str) EXTPINBATH180424_DA_0\ndata_00003_DA0.sweep_number # (uint32)\ndata_00003_DA0.electrode # (IntracellularElectrode)\ndata_00003_DA0.electrode.description # (str) Headstage 0\ndata_00003_DA0.electrode.device # (Device)\ndata_00003_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00004_DA0 = stimulus[\"data_00004_DA0\"]\ndata_00004_DA0 # (VoltageClampStimulusSeries)\ndata_00004_DA0.starting_time # (float64) 585.3480000495911\ndata_00004_DA0.rate # (float32)\ndata_00004_DA0.resolution # (float32)\ndata_00004_DA0.comments # (str) HS#0:Stim set length: 12277000.00 \\nRepeated Acq Cycle ID: 6121437.00 \\nHS#0:Stim Wave Checksum: ...\ndata_00004_DA0.description # (str) PLACEHOLDER\ndata_00004_DA0.conversion # (float32)\ndata_00004_DA0.offset # (float) 0.0\ndata_00004_DA0.unit # (str) volts\ndata_00004_DA0.data # (Dataset) shape (12297000,); dtype float32\n# data_00004_DA0.data[:] # Access all data\n# data_00004_DA0.data[0:n] # Access first n elements\ndata_00004_DA0.starting_time_unit # (str) seconds\ndata_00004_DA0.gain # (float32)\ndata_00004_DA0.stimulus_description # (str) EXTPCllATT180424_DA_0\ndata_00004_DA0.sweep_number # (uint32)\ndata_00004_DA0.electrode # (IntracellularElectrode)\ndata_00004_DA0.electrode.description # (str) Headstage 0\ndata_00004_DA0.electrode.device # (Device)\ndata_00004_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00005_DA0 = stimulus[\"data_00005_DA0\"]\ndata_00005_DA0 # (VoltageClampStimulusSeries)\ndata_00005_DA0.starting_time # (float64) 702.1389999389648\ndata_00005_DA0.rate # (float32)\ndata_00005_DA0.resolution # (float32)\ndata_00005_DA0.comments # (str) HS#0:USER_Access Res. Smoke version: 1.00 \\nHS#0:USER_Access Res. Smoke BL QC: On\\nHS#0:USER_Acce...\ndata_00005_DA0.description # (str) PLACEHOLDER\ndata_00005_DA0.conversion # (float32)\ndata_00005_DA0.offset # (float) 0.0\ndata_00005_DA0.unit # (str) volts\ndata_00005_DA0.data # (Dataset) shape (161000,); dtype float32\n# data_00005_DA0.data[:] # Access all data\n# data_00005_DA0.data[0:n] # Access first n elements\ndata_00005_DA0.starting_time_unit # (str) seconds\ndata_00005_DA0.gain # (float32)\ndata_00005_DA0.stimulus_description # (str) EXTPBREAKN180424_DA_0\ndata_00005_DA0.sweep_number # (uint32)\ndata_00005_DA0.electrode # (IntracellularElectrode)\ndata_00005_DA0.electrode.description # (str) Headstage 0\ndata_00005_DA0.electrode.device # (Device)\ndata_00005_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00006_DA0 = stimulus[\"data_00006_DA0\"]\ndata_00006_DA0 # (CurrentClampStimulusSeries)\ndata_00006_DA0.starting_time # (float64) 788.4270000457764\ndata_00006_DA0.rate # (float32)\ndata_00006_DA0.resolution # (float32)\ndata_00006_DA0.comments # (str) HS#0:DA Gain: 400.00 \\nHS#0:AD Gain: 0.01 \\nDelay onset auto: 259.07 ms\\nSampling interval multip...\ndata_00006_DA0.description # (str) PLACEHOLDER\ndata_00006_DA0.conversion # (float32)\ndata_00006_DA0.offset # (float) 0.0\ndata_00006_DA0.unit # (str) amperes\ndata_00006_DA0.data # (Dataset) shape (312953,); dtype float32\n# data_00006_DA0.data[:] # Access all data\n# data_00006_DA0.data[0:n] # Access first n elements\ndata_00006_DA0.starting_time_unit # (str) seconds\ndata_00006_DA0.gain # (float32)\ndata_00006_DA0.stimulus_description # (str) X0NRMP_DA_0\ndata_00006_DA0.sweep_number # (uint32)\ndata_00006_DA0.electrode # (IntracellularElectrode)\ndata_00006_DA0.electrode.description # (str) Headstage 0\ndata_00006_DA0.electrode.device # (Device)\ndata_00006_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\ndata_00007_DA0 = stimulus[\"data_00007_DA0\"]\ndata_00007_DA0 # (CurrentClampStimulusSeries)\ndata_00007_DA0.starting_time # (float64) 807.9530000686646\ndata_00007_DA0.rate # (float32)\ndata_00007_DA0.resolution # (float32)\ndata_00007_DA0.comments # (str) HS#0:Stim Scale Factor: -30.00 \\nIndexing: On\\nHS#0:Stim set length: 175000.00 \\nRepeated Acq Cyc...\ndata_00007_DA0.description # (str) PLACEHOLDER\ndata_00007_DA0.conversion # (float32)\ndata_00007_DA0.offset # (float) 0.0\ndata_00007_DA0.unit # (str) amperes\ndata_00007_DA0.data # (Dataset) shape (187953,); dtype float32\n# data_00007_DA0.data[:] # Access all data\n# data_00007_DA0.data[0:n] # Access first n elements\ndata_00007_DA0.starting_time_unit # (str) seconds\ndata_00007_DA0.gain # (float32)\ndata_00007_DA0.stimulus_description # (str) X1PS_SubThresh_DA_0\ndata_00007_DA0.sweep_number # (uint32)\ndata_00007_DA0.electrode # (IntracellularElectrode)\ndata_00007_DA0.electrode.description # (str) Headstage 0\ndata_00007_DA0.electrode.device # (Device)\ndata_00007_DA0.electrode.device.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\n# ...\n# Other fields: data_00008_DA0, data_00009_DA0, data_00010_DA0, data_00011_DA0, data_00012_DA0, data_00013_DA0, data_00014_DA0, data_00015_DA0, data_00016_DA0, data_00017_DA0, data_00018_DA0, data_00019_DA0, data_00020_DA0, data_00021_DA0, data_00022_DA0\n# ... and 43 more fields\nnwb.processing # (LabelledDict)\nprocessing = nwb.processing\nspikes = processing[\"spikes\"]\nspikes # (ProcessingModule)\nspikes.description # (str) detected spikes\nspikes.data_interfaces # (LabelledDict)\ndata_interfaces = spikes.data_interfaces\nSweep_12 = data_interfaces[\"Sweep_12\"]\nSweep_12 # (TimeSeries)\nSweep_12.resolution # (float64) -1.0\nSweep_12.comments # (str) no comments\nSweep_12.description # (str) no description\nSweep_12.conversion # (float64) 1.0\nSweep_12.offset # (float) 0.0\nSweep_12.unit # (str) seconds\nSweep_12.data # (Dataset) shape (0,); dtype float64\n# Sweep_12.data[:] # Access all data\n# Sweep_12.data[0:n] # Access first n elements\nSweep_12.timestamps # (Dataset) shape (0,); dtype float64\n# Sweep_12.timestamps[:] # Access all data\n# Sweep_12.timestamps[0:n] # Access first n elements\nSweep_12.timestamps_unit # (str) seconds\nSweep_12.interval # (int) 1\nSweep_19 = data_interfaces[\"Sweep_19\"]\nSweep_19 # (TimeSeries)\nSweep_19.resolution # (float64) -1.0\nSweep_19.comments # (str) no comments\nSweep_19.description # (str) no description\nSweep_19.conversion # (float64) 1.0\nSweep_19.offset # (float) 0.0\nSweep_19.unit # (str) seconds\nSweep_19.data # (Dataset) shape (12,); dtype float64\n# Sweep_19.data[:] # Access all data\n# Sweep_19.data[0:n] # Access first n elements\n# First few values of Sweep_19.data: [1.1886  1.22502 1.257   1.27972 1.30116 1.32368 1.3469  1.36998 1.39572  1.42466]\nSweep_19.timestamps # (Dataset) shape (12,); dtype float64\n# Sweep_19.timestamps[:] # Access all data\n# Sweep_19.timestamps[0:n] # Access first n elements\n# First few values of Sweep_19.timestamps: [1.1886  1.22502 1.257   1.27972 1.30116 1.32368 1.3469  1.36998 1.39572  1.42466]\nSweep_19.timestamps_unit # (str) seconds\nSweep_19.interval # (int) 1\nSweep_20 = data_interfaces[\"Sweep_20\"]\nSweep_20 # (TimeSeries)\nSweep_20.resolution # (float64) -1.0\nSweep_20.comments # (str) no comments\nSweep_20.description # (str) no description\nSweep_20.conversion # (float64) 1.0\nSweep_20.offset # (float) 0.0\nSweep_20.unit # (str) seconds\nSweep_20.data # (Dataset) shape (0,); dtype float64\n# Sweep_20.data[:] # Access all data\n# Sweep_20.data[0:n] # Access first n elements\nSweep_20.timestamps # (Dataset) shape (0,); dtype float64\n# Sweep_20.timestamps[:] # Access all data\n# Sweep_20.timestamps[0:n] # Access first n elements\nSweep_20.timestamps_unit # (str) seconds\nSweep_20.interval # (int) 1\nSweep_21 = data_interfaces[\"Sweep_21\"]\nSweep_21 # (TimeSeries)\nSweep_21.resolution # (float64) -1.0\nSweep_21.comments # (str) no comments\nSweep_21.description # (str) no description\nSweep_21.conversion # (float64) 1.0\nSweep_21.offset # (float) 0.0\nSweep_21.unit # (str) seconds\nSweep_21.data # (Dataset) shape (0,); dtype float64\n# Sweep_21.data[:] # Access all data\n# Sweep_21.data[0:n] # Access first n elements\nSweep_21.timestamps # (Dataset) shape (0,); dtype float64\n# Sweep_21.timestamps[:] # Access all data\n# Sweep_21.timestamps[0:n] # Access first n elements\nSweep_21.timestamps_unit # (str) seconds\nSweep_21.interval # (int) 1\nSweep_22 = data_interfaces[\"Sweep_22\"]\nSweep_22 # (TimeSeries)\nSweep_22.resolution # (float64) -1.0\nSweep_22.comments # (str) no comments\nSweep_22.description # (str) no description\nSweep_22.conversion # (float64) 1.0\nSweep_22.offset # (float) 0.0\nSweep_22.unit # (str) seconds\nSweep_22.data # (Dataset) shape (0,); dtype float64\n# Sweep_22.data[:] # Access all data\n# Sweep_22.data[0:n] # Access first n elements\nSweep_22.timestamps # (Dataset) shape (0,); dtype float64\n# Sweep_22.timestamps[:] # Access all data\n# Sweep_22.timestamps[0:n] # Access first n elements\nSweep_22.timestamps_unit # (str) seconds\nSweep_22.interval # (int) 1\nSweep_24 = data_interfaces[\"Sweep_24\"]\nSweep_24 # (TimeSeries)\nSweep_24.resolution # (float64) -1.0\nSweep_24.comments # (str) no comments\nSweep_24.description # (str) no description\nSweep_24.conversion # (float64) 1.0\nSweep_24.offset # (float) 0.0\nSweep_24.unit # (str) seconds\nSweep_24.data # (Dataset) shape (30,); dtype float64\n# Sweep_24.data[:] # Access all data\n# Sweep_24.data[0:n] # Access first n elements\n# First few values of Sweep_24.data: [0.58038 0.60782 0.63298 0.65542 0.67534 0.69306 0.71308 0.7316  0.75038  0.77014]\nSweep_24.timestamps # (Dataset) shape (30,); dtype float64\n# Sweep_24.timestamps[:] # Access all data\n# Sweep_24.timestamps[0:n] # Access first n elements\n# First few values of Sweep_24.timestamps: [0.58038 0.60782 0.63298 0.65542 0.67534 0.69306 0.71308 0.7316  0.75038  0.77014]\nSweep_24.timestamps_unit # (str) seconds\nSweep_24.interval # (int) 1\nSweep_25 = data_interfaces[\"Sweep_25\"]\nSweep_25 # (TimeSeries)\nSweep_25.resolution # (float64) -1.0\nSweep_25.comments # (str) no comments\nSweep_25.description # (str) no description\nSweep_25.conversion # (float64) 1.0\nSweep_25.offset # (float) 0.0\nSweep_25.unit # (str) seconds\nSweep_25.data # (Dataset) shape (34,); dtype float64\n# Sweep_25.data[:] # Access all data\n# Sweep_25.data[0:n] # Access first n elements\n# First few values of Sweep_25.data: [0.5527  0.57698 0.59886 0.61968 0.6387  0.6558  0.6732  0.69202 0.71146  0.73216]\nSweep_25.timestamps # (Dataset) shape (34,); dtype float64\n# Sweep_25.timestamps[:] # Access all data\n# Sweep_25.timestamps[0:n] # Access first n elements\n# First few values of Sweep_25.timestamps: [0.5527  0.57698 0.59886 0.61968 0.6387  0.6558  0.6732  0.69202 0.71146  0.73216]\nSweep_25.timestamps_unit # (str) seconds\nSweep_25.interval # (int) 1\nSweep_26 = data_interfaces[\"Sweep_26\"]\nSweep_26 # (TimeSeries)\nSweep_26.resolution # (float64) -1.0\nSweep_26.comments # (str) no comments\nSweep_26.description # (str) no description\nSweep_26.conversion # (float64) 1.0\nSweep_26.offset # (float) 0.0\nSweep_26.unit # (str) seconds\nSweep_26.data # (Dataset) shape (37,); dtype float64\n# Sweep_26.data[:] # Access all data\n# Sweep_26.data[0:n] # Access first n elements\n# First few values of Sweep_26.data: [0.54114 0.55966 0.57986 0.60046 0.61996 0.63834 0.65576 0.67308 0.69188  0.71104]\nSweep_26.timestamps # (Dataset) shape (37,); dtype float64\n# Sweep_26.timestamps[:] # Access all data\n# Sweep_26.timestamps[0:n] # Access first n elements\n# First few values of Sweep_26.timestamps: [0.54114 0.55966 0.57986 0.60046 0.61996 0.63834 0.65576 0.67308 0.69188  0.71104]\nSweep_26.timestamps_unit # (str) seconds\nSweep_26.interval # (int) 1\n# ...\n# Other fields: Sweep_27, Sweep_28, Sweep_29, Sweep_30, Sweep_31, Sweep_33, Sweep_45, Sweep_46, Sweep_47, Sweep_48, Sweep_49, Sweep_50, Sweep_52, Sweep_53, Sweep_54\n# ... and 5 more fields\nnwb.devices # (LabelledDict)\ndevices = nwb.devices\ndevice_ITC18USB_Dev_0 = devices[\"device_ITC18USB_Dev_0\"]\ndevice_ITC18USB_Dev_0 # (Device)\ndevice_ITC18USB_Dev_0.description # (str) Harvard Bioscience (formerly HEKA/Instrutech) Model: ITC18USB\nnwb.intervals # (LabelledDict)\nintervals = nwb.intervals\nepochs = intervals[\"epochs\"]\nepochs # (TimeIntervals)\nepochs.description # (str) experimental epochs\nepochs.colnames # (tuple) ['start_time', 'stop_time', 'tags', 'timeseries', 'treelevel']\nepochs.columns # (tuple)\nepochs.id # (ElementIdentifiers)\n# epochs.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 3352 rows and 7 columns\n# epochs.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nepochs.start_time # (VectorData) Start time of epoch, in seconds\nepochs.stop_time # (VectorData) Stop time of epoch, in seconds\nepochs.tags # (VectorIndex) Index for VectorData 'tags'\n# epochs.tags_index[0] # (ndarray)\n# epochs.tags_index[1] # (ndarray)\n# epochs.tags_index[2] # (ndarray)\n# epochs.tags_index[3] # (ndarray)\n# ...\nepochs.timeseries # (VectorIndex) Index for VectorData 'timeseries'\n# epochs.timeseries_index[0] # (list)\n# epochs.timeseries_index[1] # (list)\n# epochs.timeseries_index[2] # (list)\n# epochs.timeseries_index[3] # (list)\n# ...\nepochs.treelevel # (VectorData) Tree Level\nnwb.session_id # (str) 1207984257\nnwb.institution # (str) Allen Institute for Brain Science\nnwb.data_collection # (str)   Specified StimSet file at C:/ProgramData/AllenInstitute/MIES/MIESHDF5Files/SavedStimSets/PS_Sti...\nnwb.source_script # (str) MIES\nnwb.source_script_file_name # (str) 2022_09_07_101311\nnwb.icephys_filtering # (str) PLACEHOLDER\nnwb.subject # (Subject)\nnwb.subject.age # (str) P21170.0D\nnwb.subject.genotype # (str) \nnwb.subject.sex # (str) M\nnwb.subject.species # (str) Homo sapiens\nnwb.subject.subject_id # (str) 1203384279\nnwb.sweep_table # (SweepTable)\nnwb.sweep_table.description # (str) A sweep table groups different PatchClampSeries together.\nnwb.sweep_table.colnames # (tuple) ['series', 'sweep_number']\nnwb.sweep_table.columns # (tuple)\nnwb.sweep_table.id # (ElementIdentifiers)\n# nwb.sweep_table.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 132 rows and 3 columns\n# nwb.sweep_table.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.sweep_table.series # (VectorIndex) Index for VectorData 'series'\n# nwb.sweep_table.series_index[0] # (list)\n# nwb.sweep_table.series_index[1] # (list)\n# nwb.sweep_table.series_index[2] # (list)\n# nwb.sweep_table.series_index[3] # (list)\n# ...\nnwb.sweep_table.sweep_number # (VectorData) Sweep number of the PatchClampSeries in that row.\nnwb.epochs # (TimeIntervals)\nnwb.epochs.description # (str) experimental epochs\nnwb.epochs.colnames # (tuple) ['start_time', 'stop_time', 'tags', 'timeseries', 'treelevel']\nnwb.epochs.columns # (tuple)\nnwb.epochs.id # (ElementIdentifiers)\n# nwb.epochs.to_dataframe() # (DataFrame) Convert to a pandas DataFrame with 3352 rows and 7 columns\n# nwb.epochs.to_dataframe().head() # (DataFrame) Show the first few rows of the pandas DataFrame\nnwb.epochs.start_time # (VectorData) Start time of epoch, in seconds\nnwb.epochs.stop_time # (VectorData) Stop time of epoch, in seconds\nnwb.epochs.tags # (VectorIndex) Index for VectorData 'tags'\n# nwb.epochs.tags_index[0] # (ndarray)\n# nwb.epochs.tags_index[1] # (ndarray)\n# nwb.epochs.tags_index[2] # (ndarray)\n# nwb.epochs.tags_index[3] # (ndarray)\n# ...\nnwb.epochs.timeseries # (VectorIndex) Index for VectorData 'timeseries'\n# nwb.epochs.timeseries_index[0] # (list)\n# nwb.epochs.timeseries_index[1] # (list)\n# nwb.epochs.timeseries_index[2] # (list)\n# nwb.epochs.timeseries_index[3] # (list)\n# ...\nnwb.epochs.treelevel # (VectorData) Tree Level"
      }
    ]
  },
  {
    "role": "user",
    "content": "On the basis of the above information, please create a jupytext notebook that introduces dandiset 001359 using the format described below.\n\nThe purpose of the notebook is to help researchers explore the dandiset and get started with a reanalysis.\n\nStart with an appropriate title for the notebook, such as \"Exploring Dandiset 001359: ...\" (that should be a markdown heading).\n\nInform the user that the notebook was generated with the assistance of AI, and that they should be cautious when interpreting the code or results.\n\nProvide an overview of the Dandiset. Include a link to the Dandiset of the form https://dandiarchive.org/dandiset/001359/0.250401.1603.\n\nSummarize what the notebook covers.\n\nList the packages that are required to run the notebook. Assume that these are already installed on the user's system. Do not include any pip install commands in the notebook.\n\nShow how to use the DANDI API to load assets.\n\nShow how to load and visualize data from the dandiset based on the above information. Feel free to organize things differently from how they are in the above information, but do not make up new information.\n\nGenerate good quality plots (without being redundant).\n\nLoad NWB data by streaming the remote file (as done in the above information) rather than downloading it.\n\nDo not use any functionality of pynwb or dandi that is not covered in the above information.\n\nYou should stick to material that is covered in the above information and do not hallucinate.\n\nThroughout the notebook, include explanatory markdown cells that guide the user through the process.\n\nThe notebook should be well-documented, and follow best practices Include comments in code cells to explain what each step does.\n\nThe Jupytext should use `# %% [markdown]` for markdown cells and `# %%` delimiters for the code cells.\n\nIf any NWB have units objects, you should know the following:\nunits.spike_times_index[i] provides the vector of spike times for the i^th unit. It is actually not an index. Do not use units.spike_times.\n\nYour notebook will be evaluated based on the following criteria:\n1. How well did the notebook help you understand the purpose and content of the Dandiset?\n2. After reviewing the notebook, do you feel confident in how to access the different types of data from this Dandiset?\n3. Did the notebook help you understand the structure of the NWB file(s) and how to work with them?\n4. Did the visualizations in the notebook generally help you understand key aspects of the data?\n5. Did any of the visualizations make it harder to understand the data (e.g., due to poor formatting, unclear axes, or misleading displays)?\n6. Do you feel more confident creating your own visualizations of the data after seeing the examples in the notebook?\n7. How well did the visualizations show the structure or complexity of the data?\n8. Were there any interpretations or conclusions in the notebook that felt unclear or not well supported by the data shown?\n9. Did any of the plots or examples feel unnecessarily repetitive or redundant?\n10. Did the notebook help you understand what kinds of questions or analyses you could do next with this Dandiset?\n11. How clear and easy was the notebook to follow?\n12. Did the notebook provide code you could easily reuse or adapt to explore the Dandiset yourself?\n13. Did the notebook help you understand what kinds of questions or analyses you could do next with this Dandiset?\n14. Overall, how helpful was this notebook for getting started with this Dandiset?\n\nYour output should be in the format:\n\n<notebook>\nThe text of the jupytext notebook should appear here.\n</notebook>\n\nNo other text should be included in the response.\n"
  },
  {
    "role": "assistant",
    "content": "<notebook>\n# %% [markdown]\n# # Exploring Dandiset 001359: Multimodal Patch-seq Recordings from the Human Brain\n#\n# *Notebook generated with the assistance of AI \u2014 review and validate code/results before relying on them.*\n#\n# ---\n#\n# This interactive notebook will guide you through exploring **Dandiset 001359: \"20250331_AIBS_Patchseq_human\"**, a rich collection of multimodal Patch-seq recordings from human brain tissue provided by the Allen Institute for Brain Science in collaboration with NIMH.\n#\n# Dandiset DOI: [https://doi.org/10.48324/dandi.001359/0.250401.1603](https://doi.org/10.48324/dandi.001359/0.250401.1603)  \n# Dandiset URL: [https://dandiarchive.org/dandiset/001359/0.250401.1603](https://dandiarchive.org/dandiset/001359/0.250401.1603)\n#\n# ## About this notebook\n#\n# This notebook will help you:\n# - **Summarize** the contents and scientific context of the Dandiset\n# - **Access** and **list** the data assets (files) using the DANDI API\n# - **Stream and load NWB files** to inspect electrophysiology data, stimuli, spike detections, and subject/session metadata\n# - **Visualize** representative sweeps of intracellular voltage and current data\n# - **Guide** you through the NWB file structure so you can design your own analyses\n#\n# ---\n#\n# ## Prerequisites\n#\n# This notebook requires the following Python packages (assumed pre-installed):\n# - `dandi` (for DandiAPIClient)\n# - `remfile` (for remote file streaming)\n# - `h5py`\n# - `pynwb`\n# - `matplotlib`\n# - `numpy`\n#\n# **Note:** The code does not perform any pip installations.\n\n# %% [markdown]\n# ## Dandiset Overview\n#\n# - **Title:** 20250331_AIBS_Patchseq_human\n# - **Version:** 0.250401.1603\n# - **Total Files:** 391 NWB files\n# - **Subjects:** 33 human donors\n# - **Total Data:** ~23.8 GB\n# - **Keywords:** Patch-seq, human, multimodal\n# - **Approaches:** Current & Voltage Clamp Electrophysiology\n# - **Primary Data Standard:** NWB (Neurodata Without Borders)\n#\n# This Dandiset contains multimodal Patch-seq data\u2014simultaneous electrophysiology, morphology, and transcriptomics\u2014from single human neurons. The electrophysiological data was acquired and processed using industry-standard instrumentation and is organized using the NWB file format, making it programmatically accessible and suitable for reanalysis.\n#\n# **Typical Measurements Include:**\n# - Voltage clamp/current clamp time series\n# - Stimulus time series and metadata\n# - Detected spike times (where available)\n# - Rich session and subject metadata\n#\n# For full details, refer to the [Dandiset page](https://dandiarchive.org/dandiset/001359/0.250401.1603).\n\n# %% [markdown]\n# ## Notebook Roadmap\n#\n# 1. **Browse Dandiset Assets:** List the contained NWB files\n# 2. **Select and Load a File:** Stream a file of interest and load it into memory without explicit download\n# 3. **Explore NWB Structure:** Discover subject, session, device, electrode, acquisition, stimulus, and spike detection data\n# 4. **Visualize Example Data:** Plot representative sweeps of current clamp, voltage clamp, and related data\n# 5. **Next Steps:** Suggestions for deeper analysis\n#\n# Let's get started!\n\n# %%\n# Import core packages for accessing remote DANDI data and NWB files\n\nfrom dandi.dandiapi import DandiAPIClient             # To access DANDI assets\nimport remfile                                        # Streaming files without local download\nimport h5py                                           # For HDF5 low-level access\nimport pynwb                                          # For reading NWB files\nimport matplotlib.pyplot as plt                       # For plotting\nimport numpy as np\n\n# %% [markdown]\n# ## 1. Browsing Assets in Dandiset 001359\n#\n# Below, we connect to the DANDI Archive and list a small sample of NWB files available in this Dandiset. Each file corresponds to an intracellular electrophysiology session from a unique subject or session.\n\n# %%\n# Connect to the DANDI Archive and retrieve Dandiset 001359\n\ndandiset_id = \"001359\"\ndandiset_version = \"0.250401.1603\"\n\nclient = DandiAPIClient()\ndandiset = client.get_dandiset(dandiset_id, dandiset_version)\n\n# List NWB assets in the dandiset\nassets = list(dandiset.get_assets())\nprint(f\"Total NWB files in dandiset: {len(assets)}\\n\")\n\n# Display a few example file paths\nfor i, asset in enumerate(assets[:5]):\n    print(f\"{i+1}. {asset.path}\")\n\n# %% [markdown]\n# _**Tip:** Each NWB file follows the convention `sub-<subject_id>/sub-<subject_id>_ses-<session_id>_icephys.nwb`_\n#\n# Let's choose one file as an example to explore in detail.\n\n# %% [markdown]\n# ## 2. Streaming & Loading an NWB File\n#\n# We'll select the file\n#\n# ```\n# sub-1203384279/sub-1203384279_ses-1207984257_icephys.nwb\n# ```\n#\n# and stream it directly from the DANDI server (no local download needed) into an `NWBFile` object using `pynwb`.\n\n# %%\n# Specify the file of interest\nfile_path = \"sub-1203384279/sub-1203384279_ses-1207984257_icephys.nwb\"\n\n# Get the download URL for streaming\nasset = next(dandiset.get_assets_by_glob(file_path))\nurl = asset.download_url\n\n# Stream the file remotely and open as HDF5/NWB\nremote_file = remfile.File(url)\nh5_file = h5py.File(remote_file)\nio = pynwb.NWBHDF5IO(file=h5_file)\nnwb = io.read()\nprint(\"Loaded NWB file:\", file_path)\nprint(\"NWB session_id:\", nwb.session_id)\n\n# %% [markdown]\n# ## 3. Exploring NWB Structure: Metadata, Subject, and Devices\n#\n# Let's summarize high-level information about this session and its subject.\n\n# %%\n# Basic session metadata\nprint(\"Session Description:\", nwb.session_description)\nprint(\"Session Start Time:\", nwb.session_start_time)\nprint(\"Institution:\", nwb.institution)\nprint(\"Data Collection:\", nwb.data_collection)\nprint(\"Source Script/Filename:\", nwb.source_script_file_name)\n\n# Subject metadata\nsubject = nwb.subject\nprint(\"\\nSubject Information:\")\nprint(f\"  Subject ID: {subject.subject_id}\")\nprint(f\"  Species: {subject.species}\")\nprint(f\"  Sex: {subject.sex}\")\nprint(f\"  Age: {subject.age}\")\n\n# List devices\nprint(\"\\nDevices in file:\")\nfor k in nwb.devices:\n    print(f\"  {k}: {nwb.devices[k].description}\")\n\n# %% [markdown]\n# ## 4. Intracellular Electrode and Sweep Table\n#\n# NWB organizes data by recording channel (`electrode_0` here) and \"sweeps\" (epochs/acquisitions of data under specific stimulus/protocol).\n#\n# Let's summarize the electrode and review the sweep table.\n\n# %%\n# Examine the intracellular electrode\nelectrode = nwb.icephys_electrodes['electrode_0']\nprint(f\"Electrode description: {electrode.description}\")\nprint(f\"Electrode device: {electrode.device.description}\")\n\n# Display the first few rows of the sweep table\n# (Each row describes a sweep/recording, and which PatchClampSeries are included)\nsweep_table = nwb.sweep_table.to_dataframe()\nprint(\"\\nFirst few entries in sweep table:\")\ndisplay(sweep_table.head())\n\n# %% [markdown]\n# ## 5. Acquisition & Stimulus Series: What was Recorded?\n#\n# NWB acquisition groups PatchClamp time series for each sweep.\n#\n# Let's:\n# - List available acquisition and stimulus time series\n# - Show comments, units, and sweep numbers for the first 6 voltage or current clamp series\n\n# %%\n# List all acquisition and stimulus series available\nprint(\"Available acquisition series:\")\nfor k in list(nwb.acquisition.keys())[:10]:\n    print(f\"  {k} ({type(nwb.acquisition[k]).__name__})\")\n\nprint(\"\\nAvailable stimulus series:\")\nfor k in list(nwb.stimulus.keys())[:10]:\n    print(f\"  {k} ({type(nwb.stimulus[k]).__name__})\")\n\n# Display info for the first 6 acquisition series\nfor i in range(6):\n    series_key = f\"data_{i:05d}_AD0\"\n    acq = nwb.acquisition[series_key]\n    print(f\"\\nSeries: {series_key}\")\n    print(f\"  Type: {type(acq).__name__}\")\n    print(f\"  Sweep #: {getattr(acq, 'sweep_number', 'N/A')}\")\n    print(f\"  Unit: {acq.unit}\")\n    print(f\"  Data shape: {acq.data.shape}\")\n    print(f\"  Stimulus: {acq.stimulus_description}\")\n    print(f\"  Comments: {acq.comments[:60]}...\")\n\n# %% [markdown]\n# ## 6. Visualizing Voltage Clamp and Current Clamp Data\n#\n# Let's plot:\n# - A representative **voltage clamp** sweep (current as a function of time)\n# - The corresponding **stimulus command waveform** (applied voltage)\n# - An example **current clamp** sweep (membrane voltage)\n#\n# We'll align time axes using metadata from the NWB structure.\n\n# %%\n# Helper function to plot a single sweep and its stimulus (if available)\ndef plot_sweep(acq, stim, title, tmax=None):\n    # x axis in seconds\n    n_samples = acq.data.shape[0]\n    rate = acq.rate\n    t = np.arange(n_samples) / rate + acq.starting_time\n\n    plt.figure(figsize=(8, 3))\n    plt.plot(t, acq.data[:], color='C0', label=f\"{type(acq).__name__} ({acq.unit})\")\n    if stim is not None:\n        plt.plot(t, stim.data[:], color='C1', alpha=0.7, label='Stimulus')\n    plt.xlabel(\"Time (s)\")\n    plt.ylabel(f\"Recorded ({acq.unit})\")\n    plt.title(title)\n    plt.legend()\n    if tmax is not None:\n        plt.xlim([t[0], t[0]+tmax])\n    plt.tight_layout()\n    plt.show()\n\n# Plot a voltage clamp sweep and its stimulus\nseries_idx = 0\nacq = nwb.acquisition[f\"data_{series_idx:05d}_AD0\"]\nstim = nwb.stimulus[f\"data_{series_idx:05d}_DA0\"]\n\nplot_sweep(acq, stim, title=\"Voltage Clamp Sweep Example (current in blue, command voltage in orange)\", tmax=0.1)\n\n# Plot a current clamp sweep and its stimulus\n# Find the first CurrentClampSeries in acquisition\ncc_idx = None\nfor i, k in enumerate(nwb.acquisition.keys()):\n    if isinstance(nwb.acquisition[k], pynwb.icephys.CurrentClampSeries):\n        cc_idx = i\n        break\n\nif cc_idx is not None:\n    cc_key = list(nwb.acquisition.keys())[cc_idx]\n    acq_cc = nwb.acquisition[cc_key]\n    stim_cc = nwb.stimulus[cc_key.replace(\"_AD0\", \"_DA0\")]\n    plot_sweep(acq_cc, stim_cc, title=\"Current Clamp Sweep Example (voltage in blue, injected current in orange)\", tmax=0.1)\nelse:\n    print(\"No CurrentClampSeries found in this file.\")\n\n# %% [markdown]\n# ## 7. Exploring Detected Spikes (Processing Module)\n#\n# Some files contain spike detection results precomputed in the NWB processing module (`spikes`). Each sweep can have detected spike times (in seconds).\n#\n# Let's list sweeps for which spike times are present and plot them for an example sweep.\n\n# %%\n# Access the spike detection processing module\nspikes_mod = nwb.processing.get(\"spikes\", None)\nif spikes_mod is not None:\n    sweep_names = list(spikes_mod.data_interfaces.keys())\n    # List sweeps with non-empty data\n    spike_sweeps = [name for name in sweep_names if len(spikes_mod.data_interfaces[name].data[:]) > 0]\n    print(\"Sweeps with detected spikes:\", spike_sweeps)\n    \n    # Plot spike times for one sweep (if available)\n    if spike_sweeps:\n        name = spike_sweeps[0]\n        spikes_ts = spikes_mod.data_interfaces[name]\n        spk_times = spikes_ts.data[:]\n        plt.figure(figsize=(6, 1.5))\n        plt.eventplot([spk_times], orientation='horizontal', colors='k')\n        plt.xlabel('Time (s)')\n        plt.title(f\"Detected Spikes: {name} ({len(spk_times)} spikes)\")\n        plt.yticks([])\n        plt.tight_layout()\n        plt.show()\n    else:\n        print(\"No sweeps with spike times found in this file.\")\nelse:\n    print(\"No 'spikes' processing module present in this file.\")\n\n# %% [markdown]\n# ## 8. Working with Epochs and Experimental Intervals\n#\n# NWB files describe experimental epochs (intervals/tags for different protocol phases). These intervals provide context for time-series data and can be crucial for aligning your analysis.\n#\n# Let's display the first few epochs.\n\n# %%\n# Show a summary of experimental epochs in this NWB file\nepochs_df = nwb.epochs.to_dataframe()\nprint(\"First few epochs:\")\ndisplay(epochs_df.head())\n\n# %% [markdown]\n# ## 9. Next Steps and Further Analysis\n#\n# This notebook provided an overview and introductory exploration of Dandiset 001359, including:\n# - Accessing assets programmatically from the DANDI Archive\n# - Loading and inspecting NWB files in streamed mode\n# - Exploring subject, session, device, electrode, and sweep information\n# - Visualizing electrophysiology data and detected spikes\n#\n# **Next Steps for Deeper Analysis:**\n# - Iterate over all files (batch analysis of sweeps/metadata)\n# - Quantify basic properties (e.g., input resistance, AP thresholds)\n# - Correlate electrophysiology with donor/subject demographics\n# - Extract and analyze epochs for protocol-specific responses\n# - Link to morphology/transcriptomic data (if available)\n#\n# For more information, see the associated Dandiset protocol:  \n# [Patch-seq recording and extraction protocol](https://www.protocols.io/view/patch-seq-recording-and-extraction-8epv51n45l1b/v3)\n#\n# ---\n#\n# *Happy analyzing!*\n</notebook>\n"
  }
]